{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-21071ca1cc89bfb35edae7a363821a26a258aedd",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/BellaNapoliPredictionFactory-flattened-new.sol": "project/contracts/BellaNapoliPredictionFactory-flattened-new.sol",
    "contracts/BellaNapoliPredictionFactory-flattened-v2.sol": "project/contracts/BellaNapoliPredictionFactory-flattened-v2.sol",
    "contracts/BellaNapoliPredictionFactory.sol": "project/contracts/BellaNapoliPredictionFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/security/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "project/contracts/BellaNapoliPredictionFactory-flattened-new.sol": {
        "content": "// Sources flattened with hardhat v3.0.9 https://hardhat.org\n\n// SPDX-License-Identifier: MIT\n\n// File npm/@openzeppelin/contracts@4.9.6/utils/Context.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n\n// File npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n// File npm/@openzeppelin/contracts@4.9.6/security/ReentrancyGuard.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n\n\n// File contracts/BellaNapoliPredictionFactory.sol\n\n// Original license: SPDX_License_Identifier: MIT\npragma solidity ^0.8.24;\n\n\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    address[] public allPools;\n    mapping(address => PoolInfo) public poolInfo;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public totalFeesCollected;\n\n    struct PoolInfo {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n\n    event PoolCreated(address indexed poolAddress, string title, string category, address indexed creator, uint256 closingDate, uint256 closingBid);\n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n    event PoolWinnerSet(address indexed poolAddress, bool winner);\n    event PoolEmergencyResolved(address indexed poolAddress, bool winner, string reason);\n    event PoolEmergencyStopToggled(address indexed poolAddress, bool stopped);\n    event PoolCancelled(address indexed poolAddress, string reason);\n\n    constructor() Ownable() {}\n\n    function createPool(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid) external onlyOwner returns (address poolAddress) {\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\n        require(bytes(_title).length <= 100, \"Title too long\");\n        require(bytes(_description).length <= 500, \"Description too long\");\n        require(bytes(_category).length > 0, \"Category cannot be empty\");\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingDate <= block.timestamp + 365 days, \"Closing date too far in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        require(_closingBid <= _closingDate + 30 days, \"Closing bid too far after closing date\");\n        \n        PredictionPool newPool = new PredictionPool(_title, _description, _category, _closingDate, _closingBid, address(this));\n        poolAddress = address(newPool);\n        \n        poolInfo[poolAddress] = PoolInfo({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: msg.sender,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        allPools.push(poolAddress);\n        emit PoolCreated(poolAddress, _title, _category, msg.sender, _closingDate, _closingBid);\n        return poolAddress;\n    }\n\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool already closed\");\n        poolInfo[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n\n    function collectFees(address _poolAddress) external nonReentrant returns (uint256 feeAmount) {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool is not active\");\n        \n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        feeAmount = pool.getTotalFees();\n        totalFeesCollected += feeAmount;\n        emit FeesCollected(_poolAddress, feeAmount);\n        return feeAmount;\n    }\n\n    // ============ POOL MANAGEMENT FUNCTIONS ============\n    \n    function setPoolWinner(address _poolAddress, bool _winner) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.setWinner(_winner);\n        emit PoolWinnerSet(_poolAddress, _winner);\n    }\n    \n    function emergencyResolvePool(address _poolAddress, bool _winner, string memory _reason) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.emergencyResolve(_winner, _reason);\n        emit PoolEmergencyResolved(_poolAddress, _winner, _reason);\n    }\n    \n    function setPoolEmergencyStop(address _poolAddress, bool _stop) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.setEmergencyStop(_stop);\n        emit PoolEmergencyStopToggled(_poolAddress, _stop);\n    }\n    \n    function cancelPoolPrediction(address _poolAddress, string memory _reason) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.cancelPool(_reason);\n        emit PoolCancelled(_poolAddress, _reason);\n    }\n\n    function withdrawFees() external onlyOwner {\n        uint256 amount = totalFeesCollected;\n        totalFeesCollected = 0;\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n    }\n\n    function getPoolCount() external view returns (uint256 count) {\n        return allPools.length;\n    }\n\n    function getAllPools() external view returns (address[] memory pools) {\n        return allPools;\n    }\n\n    function getPoolInfo(address _poolAddress) external view returns (PoolInfo memory info) {\n        return poolInfo[_poolAddress];\n    }\n\n    function getPoolsByCategory(string memory _category) external view returns (address[] memory pools) {\n        // Ottimizzazione: un solo loop invece di due\n        uint256 count = 0;\n        uint256 length = allPools.length;\n        \n        // Prima passata: conta i pool che corrispondono alla categoria\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                count++;\n            }\n        }\n        \n        // Crea array con dimensione corretta\n        address[] memory result = new address[](count);\n        \n        // Seconda passata: popola l'array (solo se ci sono risultati)\n        if (count > 0) {\n            uint256 index = 0;\n            for (uint256 i = 0; i < length; i++) {\n                if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                    result[index] = allPools[i];\n                    index++;\n                    // Ottimizzazione: esci se abbiamo trovato tutti i pool\n                    if (index == count) break;\n                }\n            }\n        }\n        \n        return result;\n    }\n\n    receive() external payable {}\n}\n\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;\n    uint256 public closingBid;\n    address payable public factory;\n\n    bool public isClosed = false;\n    bool public winnerSet = false;\n    bool public winner;\n    bool public emergencyStop = false;\n    bool public cancelled = false;\n\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n\n    mapping(address => Bet) public userBets;\n    address[] public bettors;\n\n    mapping(address => bool) public hasClaimed;\n    uint256 public totalClaimed;\n\n    address public feeWallet = 0x8E49800F0AA47e68ba9e46D97481679D03379294;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct Bet {\n        bool choice;\n        uint256 amount;\n        bool claimed;\n        uint256 timestamp;\n    }\n\n    event BetPlaced(address indexed bettor, uint256 amount, bool choice, uint256 totalYes, uint256 totalNo, string predictionTitle, string userChoice);\n    event WinnerSet(bool winnerChoice, string reason);\n    event RewardClaimed(address indexed winner, uint256 amount);\n    event EmergencyStopToggled(bool stopped);\n    event PoolCancelled(string reason);\n    event RefundClaimed(address indexed user, uint256 amount);\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n\n    constructor(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid, address _factory) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = payable(_factory);\n    }\n\n    modifier bettingOpen() {\n        require(!isClosed, \"Pool is closed\");\n        require(!emergencyStop, \"Betting is paused by admin\");\n        require(!cancelled, \"Pool has been cancelled\");\n        require(block.timestamp < closingDate, \"Betting period has ended\");\n        _;\n    }\n\n    function placeBet(bool _choice) external payable bettingOpen {\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(msg.value >= 0.001 ether, \"Minimum bet is 0.001 BNB\");\n        require(msg.value <= 100 ether, \"Maximum bet is 100 BNB\");\n        require(userBets[msg.sender].amount == 0, \"User has already placed a bet\");\n        require(msg.sender != address(0), \"Invalid sender address\");\n        \n        userBets[msg.sender] = Bet({\n            choice: _choice,\n            amount: msg.value,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        bettors.push(msg.sender);\n        \n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        \n        string memory userChoiceStr = _choice ? \"YES\" : \"NO\";\n        emit BetPlaced(msg.sender, msg.value, _choice, totalYes, totalNo, title, userChoiceStr);\n    }\n\n    function closePool() external onlyOwner {\n        require(!isClosed, \"Pool already closed\");\n        require(block.timestamp >= closingDate, \"Cannot close before closing date\");\n        isClosed = true;\n    }\n\n    function setWinner(bool _winner) external onlyOwner {\n        require(isClosed, \"Pool must be closed first\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        string memory reason = _winner ? \"YES won\" : \"NO won\";\n        emit WinnerSet(_winner, reason);\n    }\n\n    function claimWinnings() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        userBets[msg.sender].claimed = true;\n        \n        uint256 userBet = userBets[msg.sender].amount;\n        uint256 totalWinningBets = winner ? totalYes : totalNo;\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        \n        // Calcolo corretto: l'utente riceve la sua quota proporzionale del pot totale\n        // meno la sua quota proporzionale delle commissioni\n        uint256 totalPot = totalBets;\n        uint256 totalFees = (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netPot = totalPot - totalFees;\n        \n        // La ricompensa è proporzionale alla scommessa dell'utente rispetto alle scommesse vincenti\n        uint256 reward = (userBet * netPot) / totalWinningBets;\n        \n        // Trasferisci le commissioni una sola volta (solo al primo claim)\n        if (totalFees > 0 && !hasClaimed[address(0)]) {\n            (bool feeSuccess, ) = payable(feeWallet).call{value: totalFees}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(feeWallet, totalFees);\n        }\n        \n        (bool success, ) = payable(msg.sender).call{value: reward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        totalClaimed += reward;\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    function setEmergencyStop(bool _stop) external onlyOwner {\n        emergencyStop = _stop;\n        emit EmergencyStopToggled(_stop);\n    }\n\n    function emergencyResolve(bool _winner, string memory _reason) external onlyOwner {\n        require(emergencyStop, \"Emergency stop not activated\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        emit WinnerSet(_winner, _reason);\n    }\n\n    function cancelPool(string memory _reason) external onlyOwner {\n        require(!winnerSet, \"Cannot cancel after winner is set\");\n        require(!cancelled, \"Pool already cancelled\");\n        cancelled = true;\n        emit PoolCancelled(_reason);\n    }\n\n    function claimRefund() external nonReentrant {\n        require(cancelled, \"Pool not cancelled\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        \n        userBets[msg.sender].claimed = true;\n        uint256 refundAmount = userBets[msg.sender].amount;\n        \n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n        \n        emit RefundClaimed(msg.sender, refundAmount);\n    }\n\n    function canClaimRefund(address _user) external view returns (bool) {\n        return cancelled && userBets[_user].amount > 0 && !userBets[_user].claimed;\n    }\n\n    function isBettingOpen() public view returns (bool) {\n        return !isClosed && !emergencyStop && !cancelled && block.timestamp < closingDate;\n    }\n\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n\n    function getPoolStats() external view returns (uint256 _totalYes, uint256 _totalNo, uint256 _totalBets, uint256 _bettorCount, bool _isClosed, bool _winnerSet, bool _cancelled) {\n        return (totalYes, totalNo, totalBets, bettors.length, isClosed, winnerSet, cancelled);\n    }\n\n    function getWinnerPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n\n    function getFeeInfo() external view returns (address _feeWallet, uint256 _feePercentage, uint256 _totalFees, bool _feesClaimed) {\n        return (feeWallet, FEE_PERCENTAGE, (winner ? totalNo : totalYes) * FEE_PERCENTAGE / BASIS_POINTS, hasClaimed[address(0)]);\n    }\n\n    function getTotalFees() external view returns (uint256) {\n        require(winnerSet, \"Winner not set yet\");\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        return (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n    }\n\n    function setFeeWallet(address _newFeeWallet) external onlyOwner {\n        require(_newFeeWallet != address(0), \"Invalid fee wallet address\");\n        require(_newFeeWallet != feeWallet, \"Same fee wallet address\");\n        feeWallet = _newFeeWallet;\n    }\n\n    receive() external payable {}\n}\n\n"
      },
      "project/contracts/BellaNapoliPredictionFactory-flattened-v2.sol": {
        "content": "// Sources flattened with hardhat v3.0.9 https://hardhat.org\n\n// SPDX-License-Identifier: MIT\n\n// File npm/@openzeppelin/contracts@4.9.6/utils/Context.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n\n// File npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n// File npm/@openzeppelin/contracts@4.9.6/security/ReentrancyGuard.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n\n\n// File contracts/BellaNapoliPredictionFactory.sol\n\n// Original license: SPDX_License_Identifier: MIT\npragma solidity ^0.8.24;\n\n\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    address[] public allPools;\n    mapping(address => PoolInfo) public poolInfo;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct PoolInfo {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n\n    event PoolCreated(address indexed poolAddress, string title, string category, address indexed creator, uint256 closingDate, uint256 closingBid);\n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event PoolReopened(address indexed poolAddress);\n    event PoolWinnerSet(address indexed poolAddress, bool winner);\n    event PoolEmergencyResolved(address indexed poolAddress, bool winner, string reason);\n    event PoolEmergencyStopToggled(address indexed poolAddress, bool stopped);\n    event PoolCancelled(address indexed poolAddress, string reason);\n    event PoolFundsRecovered(address indexed poolAddress);\n\n    constructor() Ownable() {}\n\n    function createPool(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid) external onlyOwner returns (address poolAddress) {\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\n        require(bytes(_title).length <= 100, \"Title too long\");\n        require(bytes(_description).length <= 500, \"Description too long\");\n        require(bytes(_category).length > 0, \"Category cannot be empty\");\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingDate <= block.timestamp + 365 days, \"Closing date too far in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        require(_closingBid <= _closingDate + 30 days, \"Closing bid too far after closing date\");\n        \n        PredictionPool newPool = new PredictionPool(_title, _description, _category, _closingDate, _closingBid, address(this));\n        poolAddress = address(newPool);\n        \n        poolInfo[poolAddress] = PoolInfo({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: msg.sender,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        allPools.push(poolAddress);\n        emit PoolCreated(poolAddress, _title, _category, msg.sender, _closingDate, _closingBid);\n        return poolAddress;\n    }\n\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool already closed\");\n        poolInfo[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n\n    function reopenPool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(!poolInfo[_poolAddress].isActive, \"Pool is already open\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.reopenPool();\n        poolInfo[_poolAddress].isActive = true;\n        emit PoolReopened(_poolAddress);\n    }\n\n    // ============ POOL MANAGEMENT FUNCTIONS ============\n    \n    function setPoolWinner(address _poolAddress, bool _winner) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.setWinner(_winner);\n        emit PoolWinnerSet(_poolAddress, _winner);\n    }\n    \n    function emergencyResolvePool(address _poolAddress, bool _winner, string memory _reason) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.emergencyResolve(_winner, _reason);\n        emit PoolEmergencyResolved(_poolAddress, _winner, _reason);\n    }\n    \n    function setPoolEmergencyStop(address _poolAddress, bool _stop) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.setEmergencyStop(_stop);\n        emit PoolEmergencyStopToggled(_poolAddress, _stop);\n    }\n    \n    function cancelPoolPrediction(address _poolAddress, string memory _reason) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.cancelPool(_reason);\n        emit PoolCancelled(_poolAddress, _reason);\n    }\n    \n    /// @notice Recover unclaimed funds from a cancelled pool\n    /// @dev Only callable by owner, transfers remaining funds from pool to fee wallet\n    /// @param _poolAddress The pool address to recover funds from\n    function recoverCancelledPoolFunds(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.emergencyRecoverFunds();\n        emit PoolFundsRecovered(_poolAddress);\n    }\n\n    function getPoolCount() external view returns (uint256 count) {\n        return allPools.length;\n    }\n\n    function getAllPools() external view returns (address[] memory pools) {\n        return allPools;\n    }\n\n    function getPoolInfo(address _poolAddress) external view returns (PoolInfo memory info) {\n        return poolInfo[_poolAddress];\n    }\n\n    function getPoolsByCategory(string memory _category) external view returns (address[] memory pools) {\n        // Ottimizzazione: un solo loop invece di due\n        uint256 count = 0;\n        uint256 length = allPools.length;\n        \n        // Prima passata: conta i pool che corrispondono alla categoria\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                count++;\n            }\n        }\n        \n        // Crea array con dimensione corretta\n        address[] memory result = new address[](count);\n        \n        // Seconda passata: popola l'array (solo se ci sono risultati)\n        if (count > 0) {\n            uint256 index = 0;\n            for (uint256 i = 0; i < length; i++) {\n                if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                    result[index] = allPools[i];\n                    index++;\n                    // Ottimizzazione: esci se abbiamo trovato tutti i pool\n                    if (index == count) break;\n                }\n            }\n        }\n        \n        return result;\n    }\n\n    receive() external payable {}\n}\n\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;\n    uint256 public closingBid;\n    address payable public factory;\n\n    bool public isClosed = false;\n    bool public winnerSet = false;\n    bool public winner;\n    bool public emergencyStop = false;\n    bool public cancelled = false;\n\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n\n    mapping(address => Bet) public userBets;\n    address[] public bettors;\n\n    mapping(address => bool) public hasClaimed;\n    uint256 public totalClaimed;\n\n    address public feeWallet = 0x8E49800F0AA47e68ba9e46D97481679D03379294;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct Bet {\n        bool choice;\n        uint256 amount;\n        bool claimed;\n        uint256 timestamp;\n    }\n\n    event BetPlaced(address indexed bettor, uint256 amount, bool choice, uint256 totalYes, uint256 totalNo, string predictionTitle, string userChoice);\n    event WinnerSet(bool winnerChoice, string reason);\n    event RewardClaimed(address indexed winner, uint256 amount);\n    event EmergencyStopToggled(bool stopped);\n    event PoolCancelled(string reason);\n    event RefundClaimed(address indexed user, uint256 amount);\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n    event EmergencyFundsRecovered(address indexed to, uint256 amount, uint256 userCount);\n    event PoolReopened();\n\n    constructor(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid, address _factory) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = payable(_factory);\n    }\n\n    modifier bettingOpen() {\n        require(!isClosed, \"Pool is closed\");\n        require(!emergencyStop, \"Betting is paused by admin\");\n        require(!cancelled, \"Pool has been cancelled\");\n        require(block.timestamp < closingDate, \"Betting period has ended\");\n        _;\n    }\n\n    /// @notice Place a bet on this prediction pool\n    /// @dev Users can bet YES (true) or NO (false) on the prediction\n    /// @param _choice True for YES, False for NO\n    /// Emits BetPlaced event with bet details\n    function placeBet(bool _choice) external payable bettingOpen {\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(msg.value >= 0.001 ether, \"Minimum bet is 0.001 BNB\");\n        require(msg.value <= 100 ether, \"Maximum bet is 100 BNB\");\n        require(userBets[msg.sender].amount == 0, \"User has already placed a bet\");\n        require(msg.sender != address(0), \"Invalid sender address\");\n        \n        userBets[msg.sender] = Bet({\n            choice: _choice,\n            amount: msg.value,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        bettors.push(msg.sender);\n        \n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        \n        string memory userChoiceStr = _choice ? \"YES\" : \"NO\";\n        emit BetPlaced(msg.sender, msg.value, _choice, totalYes, totalNo, title, userChoiceStr);\n    }\n\n    /// @notice Close the betting pool\n    /// @dev Only owner can close the pool at any time (except when cancelled)\n    function closePool() external onlyOwner {\n        require(!isClosed, \"Pool already closed\");\n        require(!cancelled, \"Cannot close a cancelled pool\");\n        isClosed = true;\n    }\n\n    /// @notice Reopen a closed pool (before winner is set)\n    /// @dev Only owner can reopen a pool before winner is determined\n    function reopenPool() external onlyOwner {\n        require(isClosed, \"Pool must be closed first\");\n        require(!winnerSet, \"Cannot reopen after winner is set\");\n        require(!cancelled, \"Cannot reopen a cancelled pool\");\n        isClosed = false;\n        emit PoolReopened();\n    }\n\n    /// @notice Set the winner of the prediction\n    /// @param _winner True if YES won, False if NO won\n    function setWinner(bool _winner) external onlyOwner {\n        require(isClosed, \"Pool must be closed first\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        string memory reason = _winner ? \"YES won\" : \"NO won\";\n        emit WinnerSet(_winner, reason);\n    }\n\n    /// @notice Claim your winnings if you bet on the correct outcome\n    /// @dev Winners receive a proportional share of the prize pool minus fees\n    /// Emits RewardClaimed event with reward amount\n    function claimWinnings() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        userBets[msg.sender].claimed = true;\n        \n        uint256 userBet = userBets[msg.sender].amount;\n        uint256 totalWinningBets = winner ? totalYes : totalNo;\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        \n        // Calcolo corretto: l'utente riceve la sua quota proporzionale del pot totale\n        // meno la sua quota proporzionale delle commissioni\n        uint256 totalPot = totalYes + totalNo;\n        uint256 totalFees = (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netPot = totalPot - totalFees;\n        \n        // La ricompensa è proporzionale alla scommessa dell'utente rispetto alle scommesse vincenti\n        uint256 reward = (userBet * netPot) / totalWinningBets;\n        \n        // Trasferisci le commissioni una sola volta (solo al primo claim)\n        if (totalFees > 0 && !hasClaimed[address(0)]) {\n            (bool feeSuccess, ) = payable(feeWallet).call{value: totalFees}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(feeWallet, totalFees);\n        }\n        \n        (bool success, ) = payable(msg.sender).call{value: reward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        totalClaimed += reward;\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    /// @notice Toggle emergency stop for betting\n    /// @param _stop True to pause betting, False to resume\n    function setEmergencyStop(bool _stop) external onlyOwner {\n        require(!cancelled, \"Cannot toggle emergency stop on a cancelled pool\");\n        emergencyStop = _stop;\n        emit EmergencyStopToggled(_stop);\n    }\n\n    /// @notice Emergency resolution when pool is stopped\n    /// @param _winner The winning outcome (true for YES, false for NO)\n    /// @param _reason Reason for emergency resolution\n    function emergencyResolve(bool _winner, string memory _reason) external onlyOwner {\n        require(emergencyStop, \"Emergency stop not activated\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        emit WinnerSet(_winner, _reason);\n    }\n\n    /// @notice Cancel the prediction pool\n    /// @param _reason Reason for cancellation\n    function cancelPool(string memory _reason) external onlyOwner {\n        require(!winnerSet, \"Cannot cancel after winner is set\");\n        require(!cancelled, \"Pool already cancelled\");\n        cancelled = true;\n        emit PoolCancelled(_reason);\n    }\n\n    /// @notice Claim a refund for a cancelled pool\n    /// @dev Returns the full bet amount back to the user when pool is cancelled\n    function claimRefund() external nonReentrant {\n        require(cancelled, \"Pool not cancelled\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        \n        userBets[msg.sender].claimed = true;\n        uint256 refundAmount = userBets[msg.sender].amount;\n        \n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n        \n        emit RefundClaimed(msg.sender, refundAmount);\n    }\n\n    /// @notice Emergency recovery of remaining funds from cancelled pool\n    /// @dev Only callable by owner when pool is cancelled, transfers ALL remaining funds to fee wallet\n    function emergencyRecoverFunds() external onlyOwner {\n        require(cancelled, \"Pool not cancelled\");\n        \n        uint256 remainingBalance = address(this).balance;\n        require(remainingBalance > 0, \"No remaining funds\");\n        \n        // Trasferisci TUTTI i fondi residui al fee wallet (anche se tutti hanno fatto claim)\n        (bool success, ) = payable(feeWallet).call{value: remainingBalance}(\"\");\n        require(success, \"Transfer failed\");\n        \n        emit EmergencyFundsRecovered(feeWallet, remainingBalance, bettors.length);\n    }\n\n    function canClaimRefund(address _user) external view returns (bool) {\n        return cancelled && userBets[_user].amount > 0 && !userBets[_user].claimed;\n    }\n\n    function isBettingOpen() public view returns (bool) {\n        return !isClosed && !emergencyStop && !cancelled && block.timestamp < closingDate;\n    }\n\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n\n    function getPoolStats() external view returns (uint256 _totalYes, uint256 _totalNo, uint256 _totalBets, uint256 _bettorCount, bool _isClosed, bool _winnerSet, bool _cancelled) {\n        return (totalYes, totalNo, totalBets, bettors.length, isClosed, winnerSet, cancelled);\n    }\n\n    function getWinnerPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n\n    function getFeeInfo() external view returns (address _feeWallet, uint256 _feePercentage, uint256 _totalFees, bool _feesClaimed) {\n        return (feeWallet, FEE_PERCENTAGE, (winner ? totalNo : totalYes) * FEE_PERCENTAGE / BASIS_POINTS, hasClaimed[address(0)]);\n    }\n\n    function getTotalFees() external view returns (uint256) {\n        require(winnerSet, \"Winner not set yet\");\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        return (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n    }\n\n    function setFeeWallet(address _newFeeWallet) external onlyOwner {\n        require(_newFeeWallet != address(0), \"Invalid fee wallet address\");\n        require(_newFeeWallet != feeWallet, \"Same fee wallet address\");\n        feeWallet = _newFeeWallet;\n    }\n\n    receive() external payable {}\n}\n\n"
      },
      "project/contracts/BellaNapoliPredictionFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    address[] public allPools;\n    mapping(address => PoolInfo) public poolInfo;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct PoolInfo {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n\n    event PoolCreated(address indexed poolAddress, string title, string category, address indexed creator, uint256 closingDate, uint256 closingBid);\n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event PoolReopened(address indexed poolAddress);\n    event PoolWinnerSet(address indexed poolAddress, bool winner);\n    event PoolEmergencyResolved(address indexed poolAddress, bool winner, string reason);\n    event PoolEmergencyStopToggled(address indexed poolAddress, bool stopped);\n    event PoolCancelled(address indexed poolAddress, string reason);\n    event PoolFundsRecovered(address indexed poolAddress);\n\n    constructor() Ownable() {}\n\n    function createPool(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid) external onlyOwner returns (address poolAddress) {\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\n        require(bytes(_title).length <= 100, \"Title too long\");\n        require(bytes(_description).length <= 500, \"Description too long\");\n        require(bytes(_category).length > 0, \"Category cannot be empty\");\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingDate <= block.timestamp + 365 days, \"Closing date too far in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        require(_closingBid <= _closingDate + 30 days, \"Closing bid too far after closing date\");\n        \n        PredictionPool newPool = new PredictionPool(_title, _description, _category, _closingDate, _closingBid, address(this));\n        poolAddress = address(newPool);\n        \n        poolInfo[poolAddress] = PoolInfo({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: msg.sender,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        allPools.push(poolAddress);\n        emit PoolCreated(poolAddress, _title, _category, msg.sender, _closingDate, _closingBid);\n        return poolAddress;\n    }\n\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool already closed\");\n        poolInfo[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n\n    function reopenPool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(!poolInfo[_poolAddress].isActive, \"Pool is already open\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.reopenPool();\n        poolInfo[_poolAddress].isActive = true;\n        emit PoolReopened(_poolAddress);\n    }\n\n    // ============ POOL MANAGEMENT FUNCTIONS ============\n    \n    function setPoolWinner(address _poolAddress, bool _winner) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.setWinner(_winner);\n        emit PoolWinnerSet(_poolAddress, _winner);\n    }\n    \n    function emergencyResolvePool(address _poolAddress, bool _winner, string memory _reason) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.emergencyResolve(_winner, _reason);\n        emit PoolEmergencyResolved(_poolAddress, _winner, _reason);\n    }\n    \n    function setPoolEmergencyStop(address _poolAddress, bool _stop) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.setEmergencyStop(_stop);\n        emit PoolEmergencyStopToggled(_poolAddress, _stop);\n    }\n    \n    function cancelPoolPrediction(address _poolAddress, string memory _reason) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.cancelPool(_reason);\n        emit PoolCancelled(_poolAddress, _reason);\n    }\n    \n    /// @notice Recover unclaimed funds from a cancelled pool\n    /// @dev Only callable by owner, transfers remaining funds from pool to fee wallet\n    /// @param _poolAddress The pool address to recover funds from\n    function recoverCancelledPoolFunds(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        pool.emergencyRecoverFunds();\n        emit PoolFundsRecovered(_poolAddress);\n    }\n\n    function getPoolCount() external view returns (uint256 count) {\n        return allPools.length;\n    }\n\n    function getAllPools() external view returns (address[] memory pools) {\n        return allPools;\n    }\n\n    function getPoolInfo(address _poolAddress) external view returns (PoolInfo memory info) {\n        return poolInfo[_poolAddress];\n    }\n\n    function getPoolsByCategory(string memory _category) external view returns (address[] memory pools) {\n        // Ottimizzazione: un solo loop invece di due\n        uint256 count = 0;\n        uint256 length = allPools.length;\n        \n        // Prima passata: conta i pool che corrispondono alla categoria\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                count++;\n            }\n        }\n        \n        // Crea array con dimensione corretta\n        address[] memory result = new address[](count);\n        \n        // Seconda passata: popola l'array (solo se ci sono risultati)\n        if (count > 0) {\n            uint256 index = 0;\n            for (uint256 i = 0; i < length; i++) {\n                if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                    result[index] = allPools[i];\n                    index++;\n                    // Ottimizzazione: esci se abbiamo trovato tutti i pool\n                    if (index == count) break;\n                }\n            }\n        }\n        \n        return result;\n    }\n\n    receive() external payable {}\n}\n\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;\n    uint256 public closingBid;\n    address payable public factory;\n\n    bool public isClosed = false;\n    bool public winnerSet = false;\n    bool public winner;\n    bool public emergencyStop = false;\n    bool public cancelled = false;\n\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n\n    mapping(address => Bet) public userBets;\n    address[] public bettors;\n\n    mapping(address => bool) public hasClaimed;\n    uint256 public totalClaimed;\n\n    address public feeWallet = 0x8E49800F0AA47e68ba9e46D97481679D03379294;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct Bet {\n        bool choice;\n        uint256 amount;\n        bool claimed;\n        uint256 timestamp;\n    }\n\n    event BetPlaced(address indexed bettor, uint256 amount, bool choice, uint256 totalYes, uint256 totalNo, string predictionTitle, string userChoice);\n    event WinnerSet(bool winnerChoice, string reason);\n    event RewardClaimed(address indexed winner, uint256 amount);\n    event EmergencyStopToggled(bool stopped);\n    event PoolCancelled(string reason);\n    event RefundClaimed(address indexed user, uint256 amount);\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n    event EmergencyFundsRecovered(address indexed to, uint256 amount, uint256 userCount);\n    event PoolReopened();\n\n    constructor(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid, address _factory) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = payable(_factory);\n    }\n\n    modifier bettingOpen() {\n        require(!isClosed, \"Pool is closed\");\n        require(!emergencyStop, \"Betting is paused by admin\");\n        require(!cancelled, \"Pool has been cancelled\");\n        require(block.timestamp < closingDate, \"Betting period has ended\");\n        _;\n    }\n\n    /// @notice Place a bet on this prediction pool\n    /// @dev Users can bet YES (true) or NO (false) on the prediction\n    /// @param _choice True for YES, False for NO\n    /// Emits BetPlaced event with bet details\n    function placeBet(bool _choice) external payable bettingOpen {\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(msg.value >= 0.001 ether, \"Minimum bet is 0.001 BNB\");\n        require(msg.value <= 100 ether, \"Maximum bet is 100 BNB\");\n        require(userBets[msg.sender].amount == 0, \"User has already placed a bet\");\n        require(msg.sender != address(0), \"Invalid sender address\");\n        \n        userBets[msg.sender] = Bet({\n            choice: _choice,\n            amount: msg.value,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        bettors.push(msg.sender);\n        \n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        \n        string memory userChoiceStr = _choice ? \"YES\" : \"NO\";\n        emit BetPlaced(msg.sender, msg.value, _choice, totalYes, totalNo, title, userChoiceStr);\n    }\n\n    /// @notice Close the betting pool\n    /// @dev Only owner can close the pool at any time (except when cancelled)\n    function closePool() external onlyOwner {\n        require(!isClosed, \"Pool already closed\");\n        require(!cancelled, \"Cannot close a cancelled pool\");\n        isClosed = true;\n    }\n\n    /// @notice Reopen a closed pool (before winner is set)\n    /// @dev Only owner can reopen a pool before winner is determined\n    function reopenPool() external onlyOwner {\n        require(isClosed, \"Pool must be closed first\");\n        require(!winnerSet, \"Cannot reopen after winner is set\");\n        require(!cancelled, \"Cannot reopen a cancelled pool\");\n        isClosed = false;\n        emit PoolReopened();\n    }\n\n    /// @notice Set the winner of the prediction\n    /// @param _winner True if YES won, False if NO won\n    function setWinner(bool _winner) external onlyOwner {\n        require(isClosed, \"Pool must be closed first\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        string memory reason = _winner ? \"YES won\" : \"NO won\";\n        emit WinnerSet(_winner, reason);\n    }\n\n    /// @notice Claim your winnings if you bet on the correct outcome\n    /// @dev Winners receive a proportional share of the prize pool minus fees\n    /// Emits RewardClaimed event with reward amount\n    function claimWinnings() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        userBets[msg.sender].claimed = true;\n        \n        uint256 userBet = userBets[msg.sender].amount;\n        uint256 totalWinningBets = winner ? totalYes : totalNo;\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        \n        // Calcolo corretto: l'utente riceve la sua quota proporzionale del pot totale\n        // meno la sua quota proporzionale delle commissioni\n        uint256 totalPot = totalYes + totalNo;\n        uint256 totalFees = (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netPot = totalPot - totalFees;\n        \n        // La ricompensa è proporzionale alla scommessa dell'utente rispetto alle scommesse vincenti\n        uint256 reward = (userBet * netPot) / totalWinningBets;\n        \n        // Trasferisci le commissioni una sola volta (solo al primo claim)\n        if (totalFees > 0 && !hasClaimed[address(0)]) {\n            (bool feeSuccess, ) = payable(feeWallet).call{value: totalFees}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(feeWallet, totalFees);\n        }\n        \n        (bool success, ) = payable(msg.sender).call{value: reward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        totalClaimed += reward;\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    /// @notice Toggle emergency stop for betting\n    /// @param _stop True to pause betting, False to resume\n    function setEmergencyStop(bool _stop) external onlyOwner {\n        require(!cancelled, \"Cannot toggle emergency stop on a cancelled pool\");\n        emergencyStop = _stop;\n        emit EmergencyStopToggled(_stop);\n    }\n\n    /// @notice Emergency resolution when pool is stopped\n    /// @param _winner The winning outcome (true for YES, false for NO)\n    /// @param _reason Reason for emergency resolution\n    function emergencyResolve(bool _winner, string memory _reason) external onlyOwner {\n        require(emergencyStop, \"Emergency stop not activated\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        emit WinnerSet(_winner, _reason);\n    }\n\n    /// @notice Cancel the prediction pool\n    /// @param _reason Reason for cancellation\n    function cancelPool(string memory _reason) external onlyOwner {\n        require(!winnerSet, \"Cannot cancel after winner is set\");\n        require(!cancelled, \"Pool already cancelled\");\n        cancelled = true;\n        emit PoolCancelled(_reason);\n    }\n\n    /// @notice Claim a refund for a cancelled pool\n    /// @dev Returns the full bet amount back to the user when pool is cancelled\n    function claimRefund() external nonReentrant {\n        require(cancelled, \"Pool not cancelled\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        \n        userBets[msg.sender].claimed = true;\n        uint256 refundAmount = userBets[msg.sender].amount;\n        \n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n        \n        emit RefundClaimed(msg.sender, refundAmount);\n    }\n\n    /// @notice Emergency recovery of remaining funds from cancelled pool\n    /// @dev Only callable by owner when pool is cancelled, transfers ALL remaining funds to fee wallet\n    function emergencyRecoverFunds() external onlyOwner {\n        require(cancelled, \"Pool not cancelled\");\n        \n        uint256 remainingBalance = address(this).balance;\n        require(remainingBalance > 0, \"No remaining funds\");\n        \n        // Trasferisci TUTTI i fondi residui al fee wallet (anche se tutti hanno fatto claim)\n        (bool success, ) = payable(feeWallet).call{value: remainingBalance}(\"\");\n        require(success, \"Transfer failed\");\n        \n        emit EmergencyFundsRecovered(feeWallet, remainingBalance, bettors.length);\n    }\n\n    function canClaimRefund(address _user) external view returns (bool) {\n        return cancelled && userBets[_user].amount > 0 && !userBets[_user].claimed;\n    }\n\n    function isBettingOpen() public view returns (bool) {\n        return !isClosed && !emergencyStop && !cancelled && block.timestamp < closingDate;\n    }\n\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n\n    function getPoolStats() external view returns (uint256 _totalYes, uint256 _totalNo, uint256 _totalBets, uint256 _bettorCount, bool _isClosed, bool _winnerSet, bool _cancelled) {\n        return (totalYes, totalNo, totalBets, bettors.length, isClosed, winnerSet, cancelled);\n    }\n\n    function getWinnerPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n\n    function getFeeInfo() external view returns (address _feeWallet, uint256 _feePercentage, uint256 _totalFees, bool _feesClaimed) {\n        return (feeWallet, FEE_PERCENTAGE, (winner ? totalNo : totalYes) * FEE_PERCENTAGE / BASIS_POINTS, hasClaimed[address(0)]);\n    }\n\n    function getTotalFees() external view returns (uint256) {\n        require(winnerSet, \"Winner not set yet\");\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        return (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n    }\n\n    function setFeeWallet(address _newFeeWallet) external onlyOwner {\n        require(_newFeeWallet != address(0), \"Invalid fee wallet address\");\n        require(_newFeeWallet != feeWallet, \"Same fee wallet address\");\n        feeWallet = _newFeeWallet;\n    }\n\n    receive() external payable {}\n}\n"
      }
    }
  }
}