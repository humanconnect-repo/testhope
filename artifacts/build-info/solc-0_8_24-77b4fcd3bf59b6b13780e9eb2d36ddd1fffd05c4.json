{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-77b4fcd3bf59b6b13780e9eb2d36ddd1fffd05c4",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contractweb3/BellaNapoliPredictionFactory.sol": "project/contractweb3/BellaNapoliPredictionFactory.sol",
    "contractweb3/BellaNapoliPredictionFactoryOptimized.sol": "project/contractweb3/BellaNapoliPredictionFactoryOptimized.sol",
    "contractweb3/PredictionPool.sol": "project/contractweb3/PredictionPool.sol",
    "contractweb3/SimpleStorage.sol": "project/contractweb3/SimpleStorage.sol",
    "contractweb3/TimeConfig.sol": "project/contractweb3/TimeConfig.sol",
    "contractweb3/factory-ultra-optimized.sol": "project/contractweb3/factory-ultra-optimized.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/security/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "project/contractweb3/BellaNapoliPredictionFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./PredictionPool.sol\";\n\n/**\n * @title BellaNapoliPredictionFactory\n * @dev Factory contract for creating and managing prediction pools\n * @author Bella Napoli Team\n * @notice This contract deploys and manages multiple PredictionPool contracts\n *         for the Bella Napoli prediction market platform\n */\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    \n    // ============ STATE VARIABLES ============\n    \n    /// @dev Array of all created pool addresses\n    address[] public allPools;\n    \n    /// @dev Mapping from pool address to pool metadata\n    mapping(address => PoolInfo) public poolInfo;\n    \n    /// @dev Factory fee percentage (1.5% = 150 basis points)\n    uint256 public constant FEE_PERCENTAGE = 150; // 1.5%\n    uint256 public constant BASIS_POINTS = 10000; // 100% = 10000 basis points\n    \n    /// @dev Total fees collected by the factory\n    uint256 public totalFeesCollected;\n    \n    // ============ STRUCTS ============\n    \n    struct PoolInfo {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n    \n    // ============ EVENTS ============\n    \n    event PoolCreated(\n        address indexed poolAddress,\n        string title,\n        string category,\n        address indexed creator,\n        uint256 closingDate,\n        uint256 closingBid\n    );\n    \n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n    \n    // ============ CONSTRUCTOR ============\n    \n    constructor() Ownable() {}\n    \n    // ============ EXTERNAL FUNCTIONS ============\n    \n    /**\n     * @dev Creates a new prediction pool\n     * @param _title Title of the prediction event\n     * @param _description Detailed description of the prediction\n     * @param _category Category of the prediction (e.g., \"Crypto\", \"Sports\", \"Politics\")\n     * @param _closingDate Timestamp when betting closes\n     * @param _closingBid Timestamp when the prediction event ends\n     * @return poolAddress Address of the newly created pool\n     */\n    function createPool(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid\n    ) external onlyOwner returns (address poolAddress) {\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        \n        // Deploy new PredictionPool contract\n        PredictionPool newPool = new PredictionPool(\n            _title,\n            _description,\n            _category,\n            _closingDate,\n            _closingBid,\n            address(this) // Factory address for fee collection\n        );\n        \n        poolAddress = address(newPool);\n        \n        // Store pool information\n        poolInfo[poolAddress] = PoolInfo({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: msg.sender,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        // Add to all pools array\n        allPools.push(poolAddress);\n        \n        emit PoolCreated(\n            poolAddress,\n            _title,\n            _category,\n            msg.sender,\n            _closingDate,\n            _closingBid\n        );\n        \n        return poolAddress;\n    }\n    \n    /**\n     * @dev Closes a prediction pool (emergency function)\n     * @param _poolAddress Address of the pool to close\n     */\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool already closed\");\n        \n        poolInfo[_poolAddress].isActive = false;\n        \n        emit PoolClosed(_poolAddress, false);\n    }\n    \n    /**\n     * @dev Collects fees from a pool when a user claims winnings\n     * @param _poolAddress Address of the pool\n     * @param _claimAmount Amount being claimed by the user\n     * @return feeAmount Amount of fees collected\n     */\n    function collectFees(address _poolAddress, uint256 _claimAmount) \n        external \n        nonReentrant \n        returns (uint256 feeAmount) \n    {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(msg.sender == _poolAddress, \"Only pool contract can call this\");\n        \n        feeAmount = (_claimAmount * FEE_PERCENTAGE) / BASIS_POINTS;\n        totalFeesCollected += feeAmount;\n        \n        emit FeesCollected(_poolAddress, feeAmount);\n        \n        return feeAmount;\n    }\n    \n    // ============ VIEW FUNCTIONS ============\n    \n    /**\n     * @dev Returns the total number of pools created\n     * @return count Number of pools\n     */\n    function getPoolCount() external view returns (uint256 count) {\n        return allPools.length;\n    }\n    \n    /**\n     * @dev Returns all pool addresses\n     * @return pools Array of all pool addresses\n     */\n    function getAllPools() external view returns (address[] memory pools) {\n        return allPools;\n    }\n    \n    /**\n     * @dev Returns pool information by address\n     * @param _poolAddress Address of the pool\n     * @return info Pool information struct\n     */\n    function getPoolInfo(address _poolAddress) external view returns (PoolInfo memory info) {\n        return poolInfo[_poolAddress];\n    }\n    \n    /**\n     * @dev Returns pools by category\n     * @param _category Category to filter by\n     * @return pools Array of pool addresses in the category\n     */\n    function getPoolsByCategory(string memory _category) external view returns (address[] memory pools) {\n        uint256 count = 0;\n        \n        // Count pools in category\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                count++;\n            }\n        }\n        \n        // Create result array\n        pools = new address[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                pools[index] = allPools[i];\n                index++;\n            }\n        }\n        \n        return pools;\n    }\n    \n    /**\n     * @dev Withdraws collected fees to owner\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 amount = totalFeesCollected;\n        totalFeesCollected = 0;\n        \n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n    }\n    \n    // ============ FALLBACK ============\n    \n    /**\n     * @dev Fallback function to receive ETH\n     */\n    receive() external payable {\n        // Accept direct ETH transfers\n    }\n}\n"
      },
      "project/contractweb3/BellaNapoliPredictionFactoryOptimized.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    address[] public allPools;\n    mapping(address => PoolInfo) public poolInfo;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public totalFeesCollected;\n\n    struct PoolInfo {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n\n    event PoolCreated(address indexed poolAddress, string title, string category, address indexed creator, uint256 closingDate, uint256 closingBid);\n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n\n    constructor() Ownable() {}\n\n    function createPool(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid) external onlyOwner returns (address poolAddress) {\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        \n        PredictionPool newPool = new PredictionPool(_title, _description, _category, _closingDate, _closingBid, address(this));\n        poolAddress = address(newPool);\n        \n        poolInfo[poolAddress] = PoolInfo({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: msg.sender,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        allPools.push(poolAddress);\n        emit PoolCreated(poolAddress, _title, _category, msg.sender, _closingDate, _closingBid);\n        return poolAddress;\n    }\n\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool already closed\");\n        poolInfo[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n\n    function collectFees(address _poolAddress, uint256 _claimAmount) external nonReentrant returns (uint256 feeAmount) {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool is not active\");\n        \n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        feeAmount = pool.collectFees(_claimAmount);\n        totalFeesCollected += feeAmount;\n        emit FeesCollected(_poolAddress, feeAmount);\n        return feeAmount;\n    }\n\n    function withdrawFees() external onlyOwner {\n        uint256 amount = totalFeesCollected;\n        totalFeesCollected = 0;\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n    }\n\n    function getPoolCount() external view returns (uint256 count) {\n        return allPools.length;\n    }\n\n    function getAllPools() external view returns (address[] memory pools) {\n        return allPools;\n    }\n\n    function getPoolInfo(address _poolAddress) external view returns (PoolInfo memory info) {\n        return poolInfo[_poolAddress];\n    }\n\n    function getPoolsByCategory(string memory _category) external view returns (address[] memory pools) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                count++;\n            }\n        }\n        \n        address[] memory result = new address[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                result[index] = allPools[i];\n                index++;\n            }\n        }\n        return result;\n    }\n\n    receive() external payable {}\n}\n\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;\n    uint256 public closingBid;\n    address payable public factory;\n\n    bool public isClosed = false;\n    bool public winnerSet = false;\n    bool public winner;\n    bool public emergencyStop = false;\n    bool public cancelled = false;\n\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n\n    mapping(address => Bet) public userBets;\n    address[] public bettors;\n\n    mapping(address => bool) public hasClaimed;\n    uint256 public totalClaimed;\n\n    address public constant FEE_WALLET = 0x8E49800F0AA47e68ba9e46D97481679D03379294;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct Bet {\n        bool choice;\n        uint256 amount;\n        bool claimed;\n        uint256 timestamp;\n    }\n\n    event BetPlaced(address indexed bettor, uint256 amount, bool choice, uint256 totalYes, uint256 totalNo, string predictionTitle, string userChoice);\n    event WinnerSet(bool winnerChoice, string reason);\n    event RewardClaimed(address indexed winner, uint256 amount);\n    event EmergencyStopToggled(bool stopped);\n    event PoolCancelled(string reason);\n    event RefundClaimed(address indexed user, uint256 amount);\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n\n    constructor(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid, address _factory) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = payable(_factory);\n    }\n\n    modifier bettingOpen() {\n        require(!isClosed, \"Pool is closed\");\n        require(!emergencyStop, \"Betting is paused by admin\");\n        require(!cancelled, \"Pool has been cancelled\");\n        require(block.timestamp < closingDate, \"Betting period has ended\");\n        _;\n    }\n\n    function placeBet(bool _choice) external payable bettingOpen {\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(userBets[msg.sender].amount == 0, \"User has already placed a bet\");\n        \n        userBets[msg.sender] = Bet({\n            choice: _choice,\n            amount: msg.value,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        bettors.push(msg.sender);\n        \n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        \n        string memory userChoiceStr = _choice ? \"YES\" : \"NO\";\n        emit BetPlaced(msg.sender, msg.value, _choice, totalYes, totalNo, title, userChoiceStr);\n    }\n\n    function closePool() external onlyOwner {\n        require(!isClosed, \"Pool already closed\");\n        require(block.timestamp >= closingDate, \"Cannot close before closing date\");\n        isClosed = true;\n    }\n\n    function setWinner(bool _winner) external onlyOwner {\n        require(isClosed, \"Pool must be closed first\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        string memory reason = _winner ? \"YES won\" : \"NO won\";\n        emit WinnerSet(_winner, reason);\n    }\n\n    function claimWinnings() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        userBets[msg.sender].claimed = true;\n        \n        uint256 userBet = userBets[msg.sender].amount;\n        uint256 totalWinningBets = winner ? totalYes : totalNo;\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        \n        uint256 userShare = (userBet * totalBets) / totalWinningBets;\n        uint256 feeAmount = (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 reward = userShare - (userBet * feeAmount) / totalBets;\n        \n        if (feeAmount > 0 && !hasClaimed[address(0)]) {\n            (bool feeSuccess, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        (bool success, ) = payable(msg.sender).call{value: reward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        totalClaimed += reward;\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    function setEmergencyStop(bool _stop) external onlyOwner {\n        emergencyStop = _stop;\n        emit EmergencyStopToggled(_stop);\n    }\n\n    function emergencyResolve(bool _winner, string memory _reason) external onlyOwner {\n        require(emergencyStop, \"Emergency stop not activated\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        emit WinnerSet(_winner, _reason);\n    }\n\n    function cancelPool(string memory _reason) external onlyOwner {\n        require(!winnerSet, \"Cannot cancel after winner is set\");\n        require(!cancelled, \"Pool already cancelled\");\n        cancelled = true;\n        emit PoolCancelled(_reason);\n    }\n\n    function claimRefund() external nonReentrant {\n        require(cancelled, \"Pool not cancelled\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        \n        userBets[msg.sender].claimed = true;\n        uint256 refundAmount = userBets[msg.sender].amount;\n        \n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n        \n        emit RefundClaimed(msg.sender, refundAmount);\n    }\n\n    function canClaimRefund(address _user) external view returns (bool) {\n        return cancelled && userBets[_user].amount > 0 && !userBets[_user].claimed;\n    }\n\n    function isBettingOpen() public view returns (bool) {\n        return !isClosed && !emergencyStop && !cancelled && block.timestamp < closingDate;\n    }\n\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n\n    function getPoolStats() external view returns (uint256 _totalYes, uint256 _totalNo, uint256 _totalBets, uint256 _bettorCount, bool _isClosed, bool _winnerSet, bool _cancelled) {\n        return (totalYes, totalNo, totalBets, bettors.length, isClosed, winnerSet, cancelled);\n    }\n\n    function getWinnerPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n\n    function getFeeInfo() external view returns (address _feeWallet, uint256 _feePercentage, uint256 _totalFees, bool _feesClaimed) {\n        return (FEE_WALLET, FEE_PERCENTAGE, (winner ? totalNo : totalYes) * FEE_PERCENTAGE / BASIS_POINTS, hasClaimed[address(0)]);\n    }\n\n    function collectFees(uint256 _claimAmount) external returns (uint256) {\n        require(msg.sender == factory, \"Only factory can call this\");\n        require(winnerSet, \"Winner not set yet\");\n        \n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        uint256 feeAmount = (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n        \n        if (feeAmount > 0 && !hasClaimed[address(0)]) {\n            (bool success, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(success, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        return feeAmount;\n    }\n\n    receive() external payable {}\n}\n"
      },
      "project/contractweb3/factory-ultra-optimized.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    address[] public allPools;\n    mapping(address => PoolInfo) public poolInfo;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public totalFeesCollected;\n\n    struct PoolInfo {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n\n    event PoolCreated(address indexed poolAddress, string title, string category, address indexed creator, uint256 closingDate, uint256 closingBid);\n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n\n    constructor() Ownable() {}\n\n    function createPool(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid) external onlyOwner returns (address poolAddress) {\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        \n        PredictionPool newPool = new PredictionPool(_title, _description, _category, _closingDate, _closingBid, address(this));\n        poolAddress = address(newPool);\n        \n        poolInfo[poolAddress] = PoolInfo({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: msg.sender,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        allPools.push(poolAddress);\n        emit PoolCreated(poolAddress, _title, _category, msg.sender, _closingDate, _closingBid);\n        return poolAddress;\n    }\n\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool already closed\");\n        poolInfo[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n\n    function collectFees(address _poolAddress, uint256 _claimAmount) external nonReentrant returns (uint256 feeAmount) {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool is not active\");\n        \n        PredictionPool pool = PredictionPool(payable(_poolAddress));\n        feeAmount = pool.collectFees(_claimAmount);\n        totalFeesCollected += feeAmount;\n        emit FeesCollected(_poolAddress, feeAmount);\n        return feeAmount;\n    }\n\n    function withdrawFees() external onlyOwner {\n        uint256 amount = totalFeesCollected;\n        totalFeesCollected = 0;\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n    }\n\n    function getPoolCount() external view returns (uint256 count) {\n        return allPools.length;\n    }\n\n    function getAllPools() external view returns (address[] memory pools) {\n        return allPools;\n    }\n\n    function getPoolInfo(address _poolAddress) external view returns (PoolInfo memory info) {\n        return poolInfo[_poolAddress];\n    }\n\n    function getPoolsByCategory(string memory _category) external view returns (address[] memory pools) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                count++;\n            }\n        }\n        \n        address[] memory result = new address[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                result[index] = allPools[i];\n                index++;\n            }\n        }\n        return result;\n    }\n\n    receive() external payable {}\n}\n\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;\n    uint256 public closingBid;\n    address payable public factory;\n\n    bool public isClosed = false;\n    bool public winnerSet = false;\n    bool public winner;\n    bool public emergencyStop = false;\n    bool public cancelled = false;\n\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n\n    mapping(address => Bet) public userBets;\n    address[] public bettors;\n\n    mapping(address => bool) public hasClaimed;\n    uint256 public totalClaimed;\n\n    address public constant FEE_WALLET = 0x8E49800F0AA47e68ba9e46D97481679D03379294;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct Bet {\n        bool choice;\n        uint256 amount;\n        bool claimed;\n        uint256 timestamp;\n    }\n\n    event BetPlaced(address indexed bettor, uint256 amount, bool choice, uint256 totalYes, uint256 totalNo, string predictionTitle, string userChoice);\n    event WinnerSet(bool winnerChoice, string reason);\n    event RewardClaimed(address indexed winner, uint256 amount);\n    event EmergencyStopToggled(bool stopped);\n    event PoolCancelled(string reason);\n    event RefundClaimed(address indexed user, uint256 amount);\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n\n    constructor(string memory _title, string memory _description, string memory _category, uint256 _closingDate, uint256 _closingBid, address _factory) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = payable(_factory);\n    }\n\n    modifier bettingOpen() {\n        require(!isClosed, \"Pool is closed\");\n        require(!emergencyStop, \"Betting is paused by admin\");\n        require(!cancelled, \"Pool has been cancelled\");\n        require(block.timestamp < closingDate, \"Betting period has ended\");\n        _;\n    }\n\n    function placeBet(bool _choice) external payable bettingOpen {\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(userBets[msg.sender].amount == 0, \"User has already placed a bet\");\n        \n        userBets[msg.sender] = Bet({\n            choice: _choice,\n            amount: msg.value,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        bettors.push(msg.sender);\n        \n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        \n        string memory userChoiceStr = _choice ? \"YES\" : \"NO\";\n        emit BetPlaced(msg.sender, msg.value, _choice, totalYes, totalNo, title, userChoiceStr);\n    }\n\n    function closePool() external onlyOwner {\n        require(!isClosed, \"Pool already closed\");\n        require(block.timestamp >= closingDate, \"Cannot close before closing date\");\n        isClosed = true;\n    }\n\n    function setWinner(bool _winner) external onlyOwner {\n        require(isClosed, \"Pool must be closed first\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        string memory reason = _winner ? \"YES won\" : \"NO won\";\n        emit WinnerSet(_winner, reason);\n    }\n\n    function claimWinnings() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        userBets[msg.sender].claimed = true;\n        \n        uint256 userBet = userBets[msg.sender].amount;\n        uint256 totalWinningBets = winner ? totalYes : totalNo;\n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        \n        uint256 userShare = (userBet * totalBets) / totalWinningBets;\n        uint256 feeAmount = (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 reward = userShare - (userBet * feeAmount) / totalBets;\n        \n        if (feeAmount > 0 && !hasClaimed[address(0)]) {\n            (bool feeSuccess, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        (bool success, ) = payable(msg.sender).call{value: reward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        totalClaimed += reward;\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    function setEmergencyStop(bool _stop) external onlyOwner {\n        emergencyStop = _stop;\n        emit EmergencyStopToggled(_stop);\n    }\n\n    function emergencyResolve(bool _winner, string memory _reason) external onlyOwner {\n        require(emergencyStop, \"Emergency stop not activated\");\n        require(!winnerSet, \"Winner already set\");\n        winner = _winner;\n        winnerSet = true;\n        emit WinnerSet(_winner, _reason);\n    }\n\n    function cancelPool(string memory _reason) external onlyOwner {\n        require(!winnerSet, \"Cannot cancel after winner is set\");\n        require(!cancelled, \"Pool already cancelled\");\n        cancelled = true;\n        emit PoolCancelled(_reason);\n    }\n\n    function claimRefund() external nonReentrant {\n        require(cancelled, \"Pool not cancelled\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!userBets[msg.sender].claimed, \"Already claimed\");\n        \n        userBets[msg.sender].claimed = true;\n        uint256 refundAmount = userBets[msg.sender].amount;\n        \n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n        \n        emit RefundClaimed(msg.sender, refundAmount);\n    }\n\n    function canClaimRefund(address _user) external view returns (bool) {\n        return cancelled && userBets[_user].amount > 0 && !userBets[_user].claimed;\n    }\n\n    function isBettingOpen() public view returns (bool) {\n        return !isClosed && !emergencyStop && !cancelled && block.timestamp < closingDate;\n    }\n\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n\n    function getPoolStats() external view returns (uint256 _totalYes, uint256 _totalNo, uint256 _totalBets, uint256 _bettorCount, bool _isClosed, bool _winnerSet, bool _cancelled) {\n        return (totalYes, totalNo, totalBets, bettors.length, isClosed, winnerSet, cancelled);\n    }\n\n    function getWinnerPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n\n    function getFeeInfo() external view returns (address _feeWallet, uint256 _feePercentage, uint256 _totalFees, bool _feesClaimed) {\n        return (FEE_WALLET, FEE_PERCENTAGE, (winner ? totalNo : totalYes) * FEE_PERCENTAGE / BASIS_POINTS, hasClaimed[address(0)]);\n    }\n\n    function collectFees(uint256 _claimAmount) external returns (uint256) {\n        require(msg.sender == factory, \"Only factory can call this\");\n        require(winnerSet, \"Winner not set yet\");\n        \n        uint256 totalLosingBets = winner ? totalNo : totalYes;\n        uint256 feeAmount = (totalLosingBets * FEE_PERCENTAGE) / BASIS_POINTS;\n        \n        if (feeAmount > 0 && !hasClaimed[address(0)]) {\n            (bool success, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(success, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        return feeAmount;\n    }\n\n    receive() external payable {}\n}\n"
      },
      "project/contractweb3/PredictionPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./BellaNapoliPredictionFactory.sol\";\nimport \"./TimeConfig.sol\";\n\n/**\n * @title PredictionPool\n * @dev Individual prediction pool contract for a single prediction event\n * @author Bella Napoli Team\n * @notice This contract handles betting on a single prediction event\n *         and distributes rewards to winners\n */\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    \n    // ============ STATE VARIABLES ============\n    \n    /// @dev Pool metadata\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;    // When betting closes\n    uint256 public closingBid;     // When the prediction event ends\n    address payable public factory;        // Factory contract address\n    \n    /// @dev Pool state\n    bool public isClosed = false;\n    bool public winnerSet = false;\n    bool public winner;            // true = Yes, false = No\n    bool public emergencyStop = false;  // Emergency stop for betting\n    bool public cancelled = false;      // Pool cancelled - refunds available\n    \n    /// @dev Betting totals\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n    \n    /// @dev User betting data\n    mapping(address => Bet) public userBets;\n    address[] public bettors;\n    \n    /// @dev Claiming data\n    mapping(address => bool) public hasClaimed;\n    uint256 public totalClaimed;\n    \n    /// @dev Fee configuration\n    address public constant FEE_WALLET = 0x8E49800F0AA47e68ba9e46D97481679D03379294;\n    uint256 public constant FEE_PERCENTAGE = 150; // 1.5%\n    uint256 public constant BASIS_POINTS = 10000; // 100%\n    \n    // ============ STRUCTS ============\n    \n    struct Bet {\n        uint256 amount;\n        bool choice;    // true = Yes, false = No\n        bool claimed;\n        uint256 timestamp;\n    }\n    \n    // ============ EVENTS ============\n    \n    event BetPlaced(\n        address indexed user,\n        uint256 amount,\n        bool choice,\n        uint256 totalYes,\n        uint256 totalNo,\n        string predictionTitle,\n        string userChoice\n    );\n    \n    event WinnerSet(bool winner);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event PoolClosed();\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n    event EmergencyStopToggled(bool stopped);\n    event EmergencyResolution(bool winner, string reason);\n    event PoolCancelled(string reason);\n    event RefundClaimed(address indexed user, uint256 amount);\n    \n    // ============ MODIFIERS ============\n    \n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Only factory can call this\");\n        _;\n    }\n    \n    modifier bettingOpen() {\n        require(block.timestamp <= closingDate, \"Betting period has ended\");\n        require(!isClosed, \"Pool is closed\");\n        _;\n    }\n    \n    modifier bettingClosed() {\n        require(block.timestamp > closingDate, \"Betting period is still open\");\n        _;\n    }\n    \n    // ============ CONSTRUCTOR ============\n    \n    constructor(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid,\n        address _factory\n    ) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = payable(_factory);\n    }\n    \n    // ============ EXTERNAL FUNCTIONS ============\n    \n    /**\n     * @dev Places a bet on the prediction pool\n     * @param _choice true for \"Yes\" prediction, false for \"No\" prediction\n     * @notice This function allows users to bet BNB on whether the prediction will be true or false\n     * @notice The bet amount is sent as msg.value (in BNB)\n     * @notice Users can only place one bet per pool\n     * @notice Betting is only allowed before the closing date\n     * @notice Fee: 1.5% of losing pot goes to fee wallet\n     */\n    function placeBet(bool _choice) external payable bettingOpen {\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(userBets[msg.sender].amount == 0, \"User has already placed a bet\");\n        require(!emergencyStop, \"Betting has been stopped by admin\");\n        require(!cancelled, \"Pool has been cancelled\");\n        \n        // Record the bet\n        userBets[msg.sender] = Bet({\n            amount: msg.value,\n            choice: _choice,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        // Add to bettors list if first bet\n        if (bettors.length == 0 || bettors[bettors.length - 1] != msg.sender) {\n            bettors.push(msg.sender);\n        }\n        \n        // Update totals\n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        \n        emit BetPlaced(\n            msg.sender, \n            msg.value, \n            _choice, \n            totalYes, \n            totalNo,\n            title,\n            _choice ? \"YES\" : \"NO\"\n        );\n    }\n    \n    /**\n     * @dev Sets the winner after the prediction event ends\n     * @param _winner true for Yes, false for No\n     */\n    function setWinner(bool _winner) external onlyOwner bettingClosed {\n        require(!winnerSet, \"Winner already set\");\n        require(block.timestamp > closingBid, \"Prediction event has not ended yet\");\n        \n        winner = _winner;\n        winnerSet = true;\n        isClosed = true;\n        \n        emit WinnerSet(_winner);\n        emit PoolClosed();\n    }\n    \n    /**\n     * @dev Claims rewards for winning bets\n     * @notice Fee 1.5% viene prelevata dal pool dei perdenti e inviata al wallet fisso\n     *         I vincitori ricevono il loro pool + il pool dei perdenti (dopo fee)\n     */\n    function claim() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(!isClosed || winnerSet, \"Pool not closed yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!hasClaimed[msg.sender], \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        hasClaimed[msg.sender] = true;\n        userBets[msg.sender].claimed = true;\n        \n        // Calcola i pool\n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        \n        // Calcola fee dal pool dei perdenti (1.5%)\n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        \n        // Invia fee al wallet fisso (solo al primo claim)\n        if (feeAmount > 0 && !hasClaimed[address(0)]) { // Usa un marker per evitare doppi invii\n            (bool feeSuccess, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true; // Marca che la fee è stata inviata\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        // Calcola premio del vincitore\n        uint256 userBetAmount = userBets[msg.sender].amount;\n        uint256 totalWinningPot = winningPot + netLosingPot; // Vincitori + perdenti (dopo fee)\n        uint256 userReward = (userBetAmount * totalWinningPot) / winningPot;\n        \n        totalClaimed += userReward;\n        \n        // Trasferisci premio al vincitore\n        (bool success, ) = payable(msg.sender).call{value: userReward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        emit RewardClaimed(msg.sender, userReward);\n    }\n    \n    /**\n     * @dev Emergency function to close pool (only factory owner)\n     */\n    function emergencyClose() external onlyFactory {\n        require(!isClosed, \"Pool already closed\");\n        isClosed = true;\n        emit PoolClosed();\n    }\n    \n    // ============ VIEW FUNCTIONS ============\n    \n    /**\n     * @dev Returns user's bet information\n     * @param _user User address\n     * @return bet Bet struct\n     */\n    function getUserBet(address _user) external view returns (Bet memory bet) {\n        return userBets[_user];\n    }\n    \n    /**\n     * @dev Returns all bettor addresses\n     * @return Array of bettor addresses\n     */\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n    \n    /**\n     * @dev Returns pool statistics\n     * @return _totalYes Total amount bet on Yes\n     * @return _totalNo Total amount bet on No\n     * @return _totalBets Total amount bet\n     * @return _bettorCount Number of bettors\n     * @return _isClosed Whether pool is closed\n     * @return _winnerSet Whether winner is set\n     * @return _winner The winning choice\n     */\n    function getPoolStats() external view returns (\n        uint256 _totalYes,\n        uint256 _totalNo,\n        uint256 _totalBets,\n        uint256 _bettorCount,\n        bool _isClosed,\n        bool _winnerSet,\n        bool _winner\n    ) {\n        return (\n            totalYes,\n            totalNo,\n            totalBets,\n            bettors.length,\n            isClosed,\n            winnerSet,\n            winner\n        );\n    }\n    \n    /**\n     * @dev Returns the winning pot amount\n     * @return Amount in the winning pot\n     */\n    function getWinningPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n    \n    /**\n     * @dev Returns the losing pot amount\n     * @return Amount in the losing pot\n     */\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n    \n    /**\n     * @dev Returns pool metadata\n     * @return _title Pool title\n     * @return _description Pool description\n     * @return _category Pool category\n     * @return _closingDate When betting closes\n     * @return _closingBid When prediction event ends\n     */\n    function getPoolInfo() external view returns (\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid\n    ) {\n        return (title, description, category, closingDate, closingBid);\n    }\n    \n    /**\n     * @dev Returns fee information\n     * @return _feeWallet Address that receives fees\n     * @return _feePercentage Fee percentage in basis points\n     * @return _calculatedFee Calculated fee amount from losing pot\n     * @return _feeSent Whether fee has been sent\n     */\n    function getFeeInfo() external view returns (\n        address _feeWallet,\n        uint256 _feePercentage,\n        uint256 _calculatedFee,\n        bool _feeSent\n    ) {\n        uint256 losingPot = winner ? totalNo : totalYes;\n        uint256 calculatedFee = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        bool feeSent = hasClaimed[address(0)];\n        \n        return (FEE_WALLET, FEE_PERCENTAGE, calculatedFee, feeSent);\n    }\n    \n    /**\n     * @dev Returns redistribution information\n     * @return _winningPot Amount in winning pot\n     * @return _losingPot Amount in losing pot\n     * @return _feeAmount Fee amount (1.5% of losing pot)\n     * @return _netLosingPot Losing pot after fee deduction\n     * @return _totalRedistribution Total amount to redistribute to winners\n     */\n    function getRedistributionInfo() external view returns (\n        uint256 _winningPot,\n        uint256 _losingPot,\n        uint256 _feeAmount,\n        uint256 _netLosingPot,\n        uint256 _totalRedistribution\n    ) {\n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        uint256 totalRedistribution = winningPot + netLosingPot;\n        \n        return (winningPot, losingPot, feeAmount, netLosingPot, totalRedistribution);\n    }\n    \n    // ============ ADMIN FUNCTIONS ============\n    \n    /**\n     * @dev Emergency stop/start betting (only owner)\n     * @param _stop true to stop betting, false to resume\n     */\n    function setEmergencyStop(bool _stop) external onlyOwner {\n        emergencyStop = _stop;\n        emit EmergencyStopToggled(_stop);\n    }\n    \n    /**\n     * @dev Emergency resolution - set winner immediately (only owner)\n     * @param _winner true for Yes, false for No\n     * @param _reason reason for emergency resolution\n     */\n    function emergencyResolve(bool _winner, string memory _reason) external onlyOwner {\n        require(!winnerSet, \"Winner already set\");\n        require(bytes(_reason).length > 0, \"Reason required for emergency resolution\");\n        \n        winner = _winner;\n        winnerSet = true;\n        isClosed = true;\n        emergencyStop = true; // Stop all betting\n        \n        emit EmergencyResolution(_winner, _reason);\n        emit WinnerSet(_winner);\n    }\n    \n    /**\n     * @dev Check if betting is currently open (considering emergency stop)\n     */\n    function isBettingCurrentlyOpen() external view returns (bool) {\n        return TimeConfig.isBettingOpen(closingDate) && !emergencyStop && !isClosed && !cancelled;\n    }\n    \n    /**\n     * @dev Returns human-readable information about this bet for wallet display\n     * @return description String describing what the user is doing\n     */\n    function getBetDescription() external view returns (string memory) {\n        return string(abi.encodePacked(\n            \"Place a bet on: \", title,\n            \" | Category: \", category,\n            \" | Betting closes: \", closingDate\n        ));\n    }\n    \n    /**\n     * @dev Returns the current betting status for wallet display\n     * @return status String describing if betting is open\n     */\n    function getBettingStatus() external view returns (string memory status) {\n        if (emergencyStop) return \"Betting is currently paused by admin\";\n        if (cancelled) return \"This pool has been cancelled\";\n        if (block.timestamp > closingDate) return \"Betting period has ended\";\n        return \"Betting is open - you can place your bet\";\n    }\n    \n    /**\n     * @dev Returns if the user can place a bet with detailed reason\n     * @param _user Address of the user\n     * @return canBet true if user can bet\n     * @return reason reason why user cannot bet (if applicable)\n     */\n    function canUserBet(address _user) external view returns (bool canBet, string memory reason) {\n        if (userBets[_user].amount > 0) {\n            return (false, \"You have already placed a bet in this pool\");\n        }\n        if (emergencyStop) {\n            return (false, \"Betting has been paused by admin\");\n        }\n        if (cancelled) {\n            return (false, \"This pool has been cancelled\");\n        }\n        if (block.timestamp > closingDate) {\n            return (false, \"Betting period has ended\");\n        }\n        return (true, \"You can place your bet\");\n    }\n    \n    /**\n     * @dev Cancel the pool and allow refunds (only owner)\n     * @param _reason reason for cancellation\n     */\n    function cancelPool(string memory _reason) external onlyOwner {\n        require(!winnerSet, \"Cannot cancel after winner is set\");\n        require(!cancelled, \"Pool already cancelled\");\n        require(bytes(_reason).length > 0, \"Reason required for cancellation\");\n        \n        cancelled = true;\n        isClosed = true;\n        emergencyStop = true; // Stop all betting\n        \n        emit PoolCancelled(_reason);\n    }\n    \n    /**\n     * @dev Claim refund for cancelled pool\n     */\n    function claimRefund() external nonReentrant {\n        require(cancelled, \"Pool not cancelled\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!hasClaimed[msg.sender], \"Already claimed refund\");\n        \n        uint256 refundAmount = userBets[msg.sender].amount;\n        hasClaimed[msg.sender] = true;\n        userBets[msg.sender].claimed = true;\n        \n        // Transfer refund to user\n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n        \n        emit RefundClaimed(msg.sender, refundAmount);\n    }\n    \n    /**\n     * @dev Check if user can claim refund\n     */\n    function canClaimRefund(address _user) external view returns (bool) {\n        return cancelled && \n               userBets[_user].amount > 0 && \n               !hasClaimed[_user];\n    }\n    \n    // ============ FALLBACK ============\n    \n    /**\n     * @dev Fallback function to receive ETH\n     */\n    receive() external payable {\n        // Accept direct ETH transfers\n    }\n}\n"
      },
      "project/contractweb3/SimpleStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract SimpleStorage {\n    uint256 private storedData;\n\n    function set(uint256 x) public {\n        storedData = x;\n    }\n\n    function get() public view returns (uint256) {\n        return storedData;\n    }\n}\n"
      },
      "project/contractweb3/TimeConfig.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title TimeConfig\n * @dev Configuration file for Italian timezone timestamps\n * @author Bella Napoli Team\n * @notice This library contains timestamp constants for Italian timezone\n *         All times are converted from CET (UTC+1) to UTC for blockchain compatibility\n */\nlibrary TimeConfig {\n    \n    // ============ BTC 150K PREDICTION TIMESTAMPS ============\n    \n    /// @dev Chiusura scommesse: 15 novembre 2025, 21:59 CET = 15 novembre 2025, 20:59 UTC\n    uint256 public constant BTC_150K_BETTING_CLOSE = 1763236740;\n    \n    /// @dev Scadenza prediction: 31 dicembre 2025, 21:59 CET = 31 dicembre 2025, 20:59 UTC  \n    uint256 public constant BTC_150K_PREDICTION_END = 1767211140;\n    \n    // ============ HELPER FUNCTIONS ============\n    \n    /**\n     * @dev Converts Italian time to UTC timestamp\n     * @param year Year (e.g., 2025)\n     * @param month Month (1-12)\n     * @param day Day (1-31)\n     * @param hour Hour in 24h format (0-23)\n     * @param minute Minute (0-59)\n     * @return timestamp UTC timestamp in seconds\n     * @notice Assumes CET timezone (UTC+1)\n     */\n    function italianTimeToUTC(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute\n    ) internal pure returns (uint256 timestamp) {\n        // This is a simplified conversion assuming CET (UTC+1)\n        // In production, you might want to use a more sophisticated timezone library\n        \n        // Basic validation\n        require(year >= 2024, \"Year must be 2024 or later\");\n        require(month >= 1 && month <= 12, \"Month must be 1-12\");\n        require(day >= 1 && day <= 31, \"Day must be 1-31\");\n        require(hour <= 23, \"Hour must be 0-23\");\n        require(minute <= 59, \"Minute must be 0-59\");\n        \n        // Convert to UTC by subtracting 1 hour (CET = UTC+1)\n        uint256 utcHour = hour >= 1 ? hour - 1 : 23;\n        uint256 utcDay = hour >= 1 ? day : (day > 1 ? day - 1 : 1);\n        \n        // This is a simplified calculation\n        // In production, use a proper date library\n        timestamp = (year - 1970) * 365 * 24 * 60 * 60 +\n                   (month - 1) * 30 * 24 * 60 * 60 +\n                   (utcDay - 1) * 24 * 60 * 60 +\n                   utcHour * 60 * 60 +\n                   minute * 60;\n    }\n    \n    /**\n     * @dev Checks if current time is before betting close\n     * @param bettingCloseTimestamp Betting close timestamp\n     * @return true if betting is still open\n     */\n    function isBettingOpen(uint256 bettingCloseTimestamp) internal view returns (bool) {\n        return block.timestamp <= bettingCloseTimestamp;\n    }\n    \n    /**\n     * @dev Checks if prediction event has ended\n     * @param predictionEndTimestamp Prediction end timestamp\n     * @return true if prediction event has ended\n     */\n    function isPredictionEnded(uint256 predictionEndTimestamp) internal view returns (bool) {\n        return block.timestamp > predictionEndTimestamp;\n    }\n    \n    /**\n     * @dev Gets time remaining until betting close\n     * @param bettingCloseTimestamp Betting close timestamp\n     * @return seconds remaining (0 if closed)\n     */\n    function getTimeUntilBettingClose(uint256 bettingCloseTimestamp) internal view returns (uint256) {\n        if (block.timestamp >= bettingCloseTimestamp) {\n            return 0;\n        }\n        return bettingCloseTimestamp - block.timestamp;\n    }\n    \n    /**\n     * @dev Gets time remaining until prediction end\n     * @param predictionEndTimestamp Prediction end timestamp\n     * @return seconds remaining (0 if ended)\n     */\n    function getTimeUntilPredictionEnd(uint256 predictionEndTimestamp) internal view returns (uint256) {\n        if (block.timestamp >= predictionEndTimestamp) {\n            return 0;\n        }\n        return predictionEndTimestamp - block.timestamp;\n    }\n}\n"
      }
    }
  }
}