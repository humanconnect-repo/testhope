{
  "language": "Solidity",
  "sources": {
    "BellaNapoliPredictionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// ============ OPENZEPPELIN CONTRACTS ============\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\npragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\npragma solidity ^0.8.0;\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\npragma solidity ^0.8.0;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n\n// ============ TIME CONFIG ============\n\nlibrary TimeConfig {\n    uint256 public constant REAL_CLOSING_DATE = 1763236740;\n    uint256 public constant REAL_CLOSING_BID = 1767211140;\n    \n    function isBettingOpen(uint256 _closingDate) internal view returns (bool) {\n        return block.timestamp <= _closingDate;\n    }\n    \n    function isPredictionEnded(uint256 _closingBid) internal view returns (bool) {\n        return block.timestamp > _closingBid;\n    }\n}\n\n// ============ PREDICTION POOL ============\n\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;\n    uint256 public closingBid;\n    address public factory;\n    \n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n    uint256 public totalClaimed;\n    \n    bool public winnerSet;\n    bool public winner;\n    bool public isClosed;\n    \n    mapping(address => Bet) public userBets;\n    mapping(address => bool) public hasClaimed;\n    address[] public bettors;\n    \n    address public constant FEE_WALLET = 0x17EE2ca31a6811F5d4198bCE9afd1C1db3837A38;\n    uint256 public constant FEE_PERCENTAGE = 150;\n    uint256 public constant BASIS_POINTS = 10000;\n    \n    struct Bet {\n        uint256 amount;\n        bool choice;\n        bool claimed;\n        uint256 timestamp;\n    }\n    \n    event BetPlaced(address indexed user, uint256 amount, bool choice);\n    event WinnerSet(bool winner);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n    \n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Only factory can call this function\");\n        _;\n    }\n    \n    constructor(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid,\n        address _factory\n    ) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = _factory;\n    }\n    \n    function placeBet(bool _choice) external payable nonReentrant {\n        require(TimeConfig.isBettingOpen(closingDate), \"Betting period has ended\");\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(userBets[msg.sender].amount == 0, \"Already placed a bet\");\n        \n        userBets[msg.sender] = Bet({\n            amount: msg.value,\n            choice: _choice,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        bettors.push(msg.sender);\n        \n        emit BetPlaced(msg.sender, msg.value, _choice);\n    }\n    \n    function setWinner(bool _winner) external onlyOwner {\n        require(TimeConfig.isPredictionEnded(closingBid), \"Prediction period has not ended\");\n        require(!winnerSet, \"Winner already set\");\n        \n        winner = _winner;\n        winnerSet = true;\n        isClosed = true;\n        \n        emit WinnerSet(_winner);\n    }\n    \n    function claim() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(!isClosed || winnerSet, \"Pool not closed yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!hasClaimed[msg.sender], \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        hasClaimed[msg.sender] = true;\n        userBets[msg.sender].claimed = true;\n        \n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        \n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        \n        if (feeAmount > 0 && !hasClaimed[address(0)]) { \n            (bool feeSuccess, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        uint256 userBetAmount = userBets[msg.sender].amount;\n        require(winningPot > 0, \"Winning pot is zero, no rewards to distribute\");\n        uint256 totalRedistribution = winningPot + netLosingPot;\n        uint256 userReward = (userBetAmount * totalRedistribution) / winningPot;\n        \n        totalClaimed += userReward;\n        \n        (bool success, ) = payable(msg.sender).call{value: userReward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        emit RewardClaimed(msg.sender, userReward);\n    }\n    \n    function getPoolInfo() external view returns (string memory, string memory, string memory, uint256, uint256) {\n        return (title, description, category, closingDate, closingBid);\n    }\n    \n    function getPoolStats() external view returns (uint256, uint256, uint256, uint256, bool, bool, bool) {\n        return (totalYes, totalNo, totalBets, totalClaimed, winnerSet, isClosed, winner);\n    }\n    \n    function getFeeInfo() external pure returns (address, uint256, uint256, bool) {\n        return (FEE_WALLET, FEE_PERCENTAGE, BASIS_POINTS, true);\n    }\n    \n    function getRedistributionInfo() external view returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        uint256 totalRedistribution = winningPot + netLosingPot;\n        \n        return (winningPot, losingPot, feeAmount, netLosingPot, totalRedistribution);\n    }\n    \n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n    \n    function getBet(address _user) external view returns (Bet memory) {\n        return userBets[_user];\n    }\n    \n    function getWinningPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n    \n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n    \n    receive() external payable {}\n}\n\n// ============ FACTORY ============\n\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    address[] public allPools;\n    mapping(address => PoolMetadata) public poolMetadata;\n    uint256 public totalFeesCollected;\n    \n    struct PoolMetadata {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n    \n    event PoolCreated(\n        address indexed poolAddress,\n        address indexed creator,\n        string title,\n        uint256 closingDate\n    );\n    \n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n    event FeesWithdrawn(address indexed owner, uint256 amount);\n    \n    constructor() Ownable() {}\n    \n    function createPool(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid\n    ) external onlyOwner nonReentrant returns (address) {\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\n        require(bytes(_category).length > 0, \"Category cannot be empty\");\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        \n        PredictionPool newPool = new PredictionPool(\n            _title,\n            _description,\n            _category,\n            _closingDate,\n            _closingBid,\n            address(this)\n        );\n        \n        address poolAddress = address(newPool);\n        allPools.push(poolAddress);\n        \n        poolMetadata[poolAddress] = PoolMetadata({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: _msgSender(),\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        emit PoolCreated(poolAddress, _msgSender(), _title, _closingDate);\n        \n        return poolAddress;\n    }\n    \n    function getAllPools() external view returns (address[] memory) {\n        return allPools;\n    }\n    \n    function getPoolCount() external view returns (uint256) {\n        return allPools.length;\n    }\n    \n    function getPoolInfo(address _poolAddress) external view returns (PoolMetadata memory) {\n        return poolMetadata[_poolAddress];\n    }\n    \n    function collectFees(address _poolAddress, uint256 _amount) external returns (uint256) {\n        require(poolMetadata[_poolAddress].creator != address(0), \"Pool does not exist\");\n        totalFeesCollected += _amount;\n        emit FeesCollected(_poolAddress, _amount);\n        return _amount;\n    }\n    \n    function withdrawFees() external onlyOwner nonReentrant {\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"No fees to withdraw\");\n        \n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n        \n        totalFeesCollected = 0;\n        emit FeesWithdrawn(owner(), amount);\n    }\n    \n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolMetadata[_poolAddress].creator != address(0), \"Pool does not exist\");\n        poolMetadata[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n    \n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["*"]
      }
    }
  }
}
