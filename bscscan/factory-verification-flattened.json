{
  "language": "Solidity",
  "sources": {
    "BellaNapoliPredictionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// ============ OPENZEPPELIN CONTRACTS ============\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n\n\n// ============ TIME CONFIG ============\n\n\n/**\n * @title TimeConfig\n * @dev Configuration file for Italian timezone timestamps\n * @author Bella Napoli Team\n * @notice This library contains timestamp constants for Italian timezone\n *         All times are converted from CET (UTC+1) to UTC for blockchain compatibility\n */\nlibrary TimeConfig {\n    \n    // ============ BTC 150K PREDICTION TIMESTAMPS ============\n    \n    /// @dev Chiusura scommesse: 15 novembre 2025, 21:59 CET = 15 novembre 2025, 20:59 UTC\n    uint256 public constant BTC_150K_BETTING_CLOSE = 1763236740;\n    \n    /// @dev Scadenza prediction: 31 dicembre 2025, 21:59 CET = 31 dicembre 2025, 20:59 UTC  \n    uint256 public constant BTC_150K_PREDICTION_END = 1767211140;\n    \n    // ============ HELPER FUNCTIONS ============\n    \n    /**\n     * @dev Converts Italian time to UTC timestamp\n     * @param year Year (e.g., 2025)\n     * @param month Month (1-12)\n     * @param day Day (1-31)\n     * @param hour Hour in 24h format (0-23)\n     * @param minute Minute (0-59)\n     * @return timestamp UTC timestamp in seconds\n     * @notice Assumes CET timezone (UTC+1)\n     */\n    function italianTimeToUTC(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute\n    ) internal pure returns (uint256 timestamp) {\n        // This is a simplified conversion assuming CET (UTC+1)\n        // In production, you might want to use a more sophisticated timezone library\n        \n        // Basic validation\n        require(year >= 2024, \"Year must be 2024 or later\");\n        require(month >= 1 && month <= 12, \"Month must be 1-12\");\n        require(day >= 1 && day <= 31, \"Day must be 1-31\");\n        require(hour <= 23, \"Hour must be 0-23\");\n        require(minute <= 59, \"Minute must be 0-59\");\n        \n        // Convert to UTC by subtracting 1 hour (CET = UTC+1)\n        uint256 utcHour = hour >= 1 ? hour - 1 : 23;\n        uint256 utcDay = hour >= 1 ? day : (day > 1 ? day - 1 : 1);\n        \n        // This is a simplified calculation\n        // In production, use a proper date library\n        timestamp = (year - 1970) * 365 * 24 * 60 * 60 +\n                   (month - 1) * 30 * 24 * 60 * 60 +\n                   (utcDay - 1) * 24 * 60 * 60 +\n                   utcHour * 60 * 60 +\n                   minute * 60;\n    }\n    \n    /**\n     * @dev Checks if current time is before betting close\n     * @param bettingCloseTimestamp Betting close timestamp\n     * @return true if betting is still open\n     */\n    function isBettingOpen(uint256 bettingCloseTimestamp) internal view returns (bool) {\n        return block.timestamp <= bettingCloseTimestamp;\n    }\n    \n    /**\n     * @dev Checks if prediction event has ended\n     * @param predictionEndTimestamp Prediction end timestamp\n     * @return true if prediction event has ended\n     */\n    function isPredictionEnded(uint256 predictionEndTimestamp) internal view returns (bool) {\n        return block.timestamp > predictionEndTimestamp;\n    }\n    \n    /**\n     * @dev Gets time remaining until betting close\n     * @param bettingCloseTimestamp Betting close timestamp\n     * @return seconds remaining (0 if closed)\n     */\n    function getTimeUntilBettingClose(uint256 bettingCloseTimestamp) internal view returns (uint256) {\n        if (block.timestamp >= bettingCloseTimestamp) {\n            return 0;\n        }\n        return bettingCloseTimestamp - block.timestamp;\n    }\n    \n    /**\n     * @dev Gets time remaining until prediction end\n     * @param predictionEndTimestamp Prediction end timestamp\n     * @return seconds remaining (0 if ended)\n     */\n    function getTimeUntilPredictionEnd(uint256 predictionEndTimestamp) internal view returns (uint256) {\n        if (block.timestamp >= predictionEndTimestamp) {\n            return 0;\n        }\n        return predictionEndTimestamp - block.timestamp;\n    }\n}\n\n\n// ============ PREDICTION POOL ============\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./BellaNapoliPredictionFactory.sol\";\nimport \"./TimeConfig.sol\";\n\n/**\n * @title PredictionPool\n * @dev Individual prediction pool contract for a single prediction event\n * @author Bella Napoli Team\n * @notice This contract handles betting on a single prediction event\n *         and distributes rewards to winners\n */\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    \n    // ============ STATE VARIABLES ============\n    \n    /// @dev Pool metadata\n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;    // When betting closes\n    uint256 public closingBid;     // When the prediction event ends\n    address payable public factory;        // Factory contract address\n    \n    /// @dev Pool state\n    bool public isClosed = false;\n    bool public winnerSet = false;\n    bool public winner;            // true = Yes, false = No\n    \n    /// @dev Betting totals\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n    \n    /// @dev User betting data\n    mapping(address => Bet) public userBets;\n    address[] public bettors;\n    \n    /// @dev Claiming data\n    mapping(address => bool) public hasClaimed;\n    uint256 public totalClaimed;\n    \n    /// @dev Fee configuration\n    address public constant FEE_WALLET = 0x17EE2ca31a6811F5d4198bCE9afd1C1db3837A38;\n    uint256 public constant FEE_PERCENTAGE = 150; // 1.5%\n    uint256 public constant BASIS_POINTS = 10000; // 100%\n    \n    // ============ STRUCTS ============\n    \n    struct Bet {\n        uint256 amount;\n        bool choice;    // true = Yes, false = No\n        bool claimed;\n        uint256 timestamp;\n    }\n    \n    // ============ EVENTS ============\n    \n    event BetPlaced(\n        address indexed user,\n        uint256 amount,\n        bool choice,\n        uint256 totalYes,\n        uint256 totalNo\n    );\n    \n    event WinnerSet(bool winner);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event PoolClosed();\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n    \n    // ============ MODIFIERS ============\n    \n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Only factory can call this\");\n        _;\n    }\n    \n    modifier bettingOpen() {\n        require(block.timestamp <= closingDate, \"Betting period has ended\");\n        require(!isClosed, \"Pool is closed\");\n        _;\n    }\n    \n    modifier bettingClosed() {\n        require(block.timestamp > closingDate, \"Betting period is still open\");\n        _;\n    }\n    \n    // ============ CONSTRUCTOR ============\n    \n    constructor(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid,\n        address _factory\n    ) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = payable(_factory);\n    }\n    \n    // ============ EXTERNAL FUNCTIONS ============\n    \n    /**\n     * @dev Places a bet on Yes or No\n     * @param _choice true for Yes, false for No\n     */\n    function placeBet(bool _choice) external payable bettingOpen {\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(userBets[msg.sender].amount == 0, \"User has already placed a bet\");\n        \n        // Record the bet\n        userBets[msg.sender] = Bet({\n            amount: msg.value,\n            choice: _choice,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        // Add to bettors list if first bet\n        if (bettors.length == 0 || bettors[bettors.length - 1] != msg.sender) {\n            bettors.push(msg.sender);\n        }\n        \n        // Update totals\n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        \n        emit BetPlaced(msg.sender, msg.value, _choice, totalYes, totalNo);\n    }\n    \n    /**\n     * @dev Sets the winner after the prediction event ends\n     * @param _winner true for Yes, false for No\n     */\n    function setWinner(bool _winner) external onlyOwner bettingClosed {\n        require(!winnerSet, \"Winner already set\");\n        require(block.timestamp > closingBid, \"Prediction event has not ended yet\");\n        \n        winner = _winner;\n        winnerSet = true;\n        isClosed = true;\n        \n        emit WinnerSet(_winner);\n        emit PoolClosed();\n    }\n    \n    /**\n     * @dev Claims rewards for winning bets\n     * @notice Fee 1.5% viene prelevata dal pool dei perdenti e inviata al wallet fisso\n     *         I vincitori ricevono il loro pool + il pool dei perdenti (dopo fee)\n     */\n    function claim() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(!isClosed || winnerSet, \"Pool not closed yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!hasClaimed[msg.sender], \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        hasClaimed[msg.sender] = true;\n        userBets[msg.sender].claimed = true;\n        \n        // Calcola i pool\n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        \n        // Calcola fee dal pool dei perdenti (1.5%)\n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        \n        // Invia fee al wallet fisso (solo al primo claim)\n        if (feeAmount > 0 && !hasClaimed[address(0)]) { // Usa un marker per evitare doppi invii\n            (bool feeSuccess, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true; // Marca che la fee è stata inviata\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        // Calcola premio del vincitore\n        uint256 userBetAmount = userBets[msg.sender].amount;\n        uint256 totalWinningPot = winningPot + netLosingPot; // Vincitori + perdenti (dopo fee)\n        uint256 userReward = (userBetAmount * totalWinningPot) / winningPot;\n        \n        totalClaimed += userReward;\n        \n        // Trasferisci premio al vincitore\n        (bool success, ) = payable(msg.sender).call{value: userReward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        emit RewardClaimed(msg.sender, userReward);\n    }\n    \n    /**\n     * @dev Emergency function to close pool (only factory owner)\n     */\n    function emergencyClose() external onlyFactory {\n        require(!isClosed, \"Pool already closed\");\n        isClosed = true;\n        emit PoolClosed();\n    }\n    \n    // ============ VIEW FUNCTIONS ============\n    \n    /**\n     * @dev Returns user's bet information\n     * @param _user User address\n     * @return bet Bet struct\n     */\n    function getUserBet(address _user) external view returns (Bet memory bet) {\n        return userBets[_user];\n    }\n    \n    /**\n     * @dev Returns all bettor addresses\n     * @return Array of bettor addresses\n     */\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n    \n    /**\n     * @dev Returns pool statistics\n     * @return _totalYes Total amount bet on Yes\n     * @return _totalNo Total amount bet on No\n     * @return _totalBets Total amount bet\n     * @return _bettorCount Number of bettors\n     * @return _isClosed Whether pool is closed\n     * @return _winnerSet Whether winner is set\n     * @return _winner The winning choice\n     */\n    function getPoolStats() external view returns (\n        uint256 _totalYes,\n        uint256 _totalNo,\n        uint256 _totalBets,\n        uint256 _bettorCount,\n        bool _isClosed,\n        bool _winnerSet,\n        bool _winner\n    ) {\n        return (\n            totalYes,\n            totalNo,\n            totalBets,\n            bettors.length,\n            isClosed,\n            winnerSet,\n            winner\n        );\n    }\n    \n    /**\n     * @dev Returns the winning pot amount\n     * @return Amount in the winning pot\n     */\n    function getWinningPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n    \n    /**\n     * @dev Returns the losing pot amount\n     * @return Amount in the losing pot\n     */\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n    \n    /**\n     * @dev Returns pool metadata\n     * @return _title Pool title\n     * @return _description Pool description\n     * @return _category Pool category\n     * @return _closingDate When betting closes\n     * @return _closingBid When prediction event ends\n     */\n    function getPoolInfo() external view returns (\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid\n    ) {\n        return (title, description, category, closingDate, closingBid);\n    }\n    \n    /**\n     * @dev Returns fee information\n     * @return _feeWallet Address that receives fees\n     * @return _feePercentage Fee percentage in basis points\n     * @return _calculatedFee Calculated fee amount from losing pot\n     * @return _feeSent Whether fee has been sent\n     */\n    function getFeeInfo() external view returns (\n        address _feeWallet,\n        uint256 _feePercentage,\n        uint256 _calculatedFee,\n        bool _feeSent\n    ) {\n        uint256 losingPot = winner ? totalNo : totalYes;\n        uint256 calculatedFee = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        bool feeSent = hasClaimed[address(0)];\n        \n        return (FEE_WALLET, FEE_PERCENTAGE, calculatedFee, feeSent);\n    }\n    \n    /**\n     * @dev Returns redistribution information\n     * @return _winningPot Amount in winning pot\n     * @return _losingPot Amount in losing pot\n     * @return _feeAmount Fee amount (1.5% of losing pot)\n     * @return _netLosingPot Losing pot after fee deduction\n     * @return _totalRedistribution Total amount to redistribute to winners\n     */\n    function getRedistributionInfo() external view returns (\n        uint256 _winningPot,\n        uint256 _losingPot,\n        uint256 _feeAmount,\n        uint256 _netLosingPot,\n        uint256 _totalRedistribution\n    ) {\n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        uint256 totalRedistribution = winningPot + netLosingPot;\n        \n        return (winningPot, losingPot, feeAmount, netLosingPot, totalRedistribution);\n    }\n    \n    // ============ FALLBACK ============\n    \n    /**\n     * @dev Fallback function to receive ETH\n     */\n    receive() external payable {\n        // Accept direct ETH transfers\n    }\n}\n\n\n// ============ FACTORY ============\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./PredictionPool.sol\";\n\n/**\n * @title BellaNapoliPredictionFactory\n * @dev Factory contract for creating and managing prediction pools\n * @author Bella Napoli Team\n * @notice This contract deploys and manages multiple PredictionPool contracts\n *         for the Bella Napoli prediction market platform\n */\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    \n    // ============ STATE VARIABLES ============\n    \n    /// @dev Array of all created pool addresses\n    address[] public allPools;\n    \n    /// @dev Mapping from pool address to pool metadata\n    mapping(address => PoolInfo) public poolInfo;\n    \n    /// @dev Factory fee percentage (1.5% = 150 basis points)\n    uint256 public constant FEE_PERCENTAGE = 150; // 1.5%\n    uint256 public constant BASIS_POINTS = 10000; // 100% = 10000 basis points\n    \n    /// @dev Total fees collected by the factory\n    uint256 public totalFeesCollected;\n    \n    // ============ STRUCTS ============\n    \n    struct PoolInfo {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n    \n    // ============ EVENTS ============\n    \n    event PoolCreated(\n        address indexed poolAddress,\n        string title,\n        string category,\n        address indexed creator,\n        uint256 closingDate,\n        uint256 closingBid\n    );\n    \n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n    \n    // ============ CONSTRUCTOR ============\n    \n    constructor() Ownable() {}\n    \n    // ============ EXTERNAL FUNCTIONS ============\n    \n    /**\n     * @dev Creates a new prediction pool\n     * @param _title Title of the prediction event\n     * @param _description Detailed description of the prediction\n     * @param _category Category of the prediction (e.g., \"Crypto\", \"Sports\", \"Politics\")\n     * @param _closingDate Timestamp when betting closes\n     * @param _closingBid Timestamp when the prediction event ends\n     * @return poolAddress Address of the newly created pool\n     */\n    function createPool(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid\n    ) external onlyOwner returns (address poolAddress) {\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        \n        // Deploy new PredictionPool contract\n        PredictionPool newPool = new PredictionPool(\n            _title,\n            _description,\n            _category,\n            _closingDate,\n            _closingBid,\n            address(this) // Factory address for fee collection\n        );\n        \n        poolAddress = address(newPool);\n        \n        // Store pool information\n        poolInfo[poolAddress] = PoolInfo({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: msg.sender,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        // Add to all pools array\n        allPools.push(poolAddress);\n        \n        emit PoolCreated(\n            poolAddress,\n            _title,\n            _category,\n            msg.sender,\n            _closingDate,\n            _closingBid\n        );\n        \n        return poolAddress;\n    }\n    \n    /**\n     * @dev Closes a prediction pool (emergency function)\n     * @param _poolAddress Address of the pool to close\n     */\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(poolInfo[_poolAddress].isActive, \"Pool already closed\");\n        \n        poolInfo[_poolAddress].isActive = false;\n        \n        emit PoolClosed(_poolAddress, false);\n    }\n    \n    /**\n     * @dev Collects fees from a pool when a user claims winnings\n     * @param _poolAddress Address of the pool\n     * @param _claimAmount Amount being claimed by the user\n     * @return feeAmount Amount of fees collected\n     */\n    function collectFees(address _poolAddress, uint256 _claimAmount) \n        external \n        nonReentrant \n        returns (uint256 feeAmount) \n    {\n        require(poolInfo[_poolAddress].creator != address(0), \"Pool does not exist\");\n        require(msg.sender == _poolAddress, \"Only pool contract can call this\");\n        \n        feeAmount = (_claimAmount * FEE_PERCENTAGE) / BASIS_POINTS;\n        totalFeesCollected += feeAmount;\n        \n        emit FeesCollected(_poolAddress, feeAmount);\n        \n        return feeAmount;\n    }\n    \n    // ============ VIEW FUNCTIONS ============\n    \n    /**\n     * @dev Returns the total number of pools created\n     * @return count Number of pools\n     */\n    function getPoolCount() external view returns (uint256 count) {\n        return allPools.length;\n    }\n    \n    /**\n     * @dev Returns all pool addresses\n     * @return pools Array of all pool addresses\n     */\n    function getAllPools() external view returns (address[] memory pools) {\n        return allPools;\n    }\n    \n    /**\n     * @dev Returns pool information by address\n     * @param _poolAddress Address of the pool\n     * @return info Pool information struct\n     */\n    function getPoolInfo(address _poolAddress) external view returns (PoolInfo memory info) {\n        return poolInfo[_poolAddress];\n    }\n    \n    /**\n     * @dev Returns pools by category\n     * @param _category Category to filter by\n     * @return pools Array of pool addresses in the category\n     */\n    function getPoolsByCategory(string memory _category) external view returns (address[] memory pools) {\n        uint256 count = 0;\n        \n        // Count pools in category\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                count++;\n            }\n        }\n        \n        // Create result array\n        pools = new address[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (keccak256(bytes(poolInfo[allPools[i]].category)) == keccak256(bytes(_category))) {\n                pools[index] = allPools[i];\n                index++;\n            }\n        }\n        \n        return pools;\n    }\n    \n    /**\n     * @dev Withdraws collected fees to owner\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 amount = totalFeesCollected;\n        totalFeesCollected = 0;\n        \n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n    }\n    \n    // ============ FALLBACK ============\n    \n    /**\n     * @dev Fallback function to receive ETH\n     */\n    receive() external payable {\n        // Accept direct ETH transfers\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["*"]
      }
    }
  }
}
