{
  "language": "Solidity",
  "sources": {
    "BellaNapoliPredictionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./PredictionPool.sol\";\n\n/**\n * @title BellaNapoliPredictionFactory\n * @dev Factory contract for creating and managing prediction pools\n * @author Bella Napoli Team\n */\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    // ============ STATE VARIABLES ============\n    \n    address[] public allPools;\n    mapping(address => PoolMetadata) public poolMetadata;\n    uint256 public totalFeesCollected;\n    \n    // ============ STRUCTS ============\n    \n    struct PoolMetadata {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n    \n    // ============ EVENTS ============\n    \n    event PoolCreated(\n        address indexed poolAddress,\n        address indexed creator,\n        string title,\n        string category,\n        uint256 closingDate,\n        uint256 closingBid\n    );\n    \n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n    event FeesWithdrawn(address indexed owner, uint256 amount);\n    \n    // ============ CONSTRUCTOR ============\n    \n    constructor() Ownable() {}\n    \n    // ============ EXTERNAL FUNCTIONS ============\n    \n    /**\n     * @dev Creates a new prediction pool\n     * @param _title Title of the prediction\n     * @param _description Description of the prediction\n     * @param _category Category (e.g., \"Crypto\", \"Sports\", \"Politics\")\n     * @param _closingDate Unix timestamp when betting closes\n     * @param _closingBid Unix timestamp when prediction expires\n     * @return Address of the created pool\n     */\n    function createPool(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid\n    ) external onlyOwner nonReentrant returns (address) {\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\n        require(bytes(_category).length > 0, \"Category cannot be empty\");\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        \n        PredictionPool newPool = new PredictionPool(\n            _title,\n            _description,\n            _category,\n            _closingDate,\n            _closingBid,\n            address(this)\n        );\n        \n        address poolAddress = address(newPool);\n        allPools.push(poolAddress);\n        \n        poolMetadata[poolAddress] = PoolMetadata({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: _msgSender(),\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        emit PoolCreated(poolAddress, _msgSender(), _title, _category, _closingDate, _closingBid);\n        \n        return poolAddress;\n    }\n    \n    /**\n     * @dev Returns all created pools\n     * @return Array of pool addresses\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return allPools;\n    }\n    \n    /**\n     * @dev Returns the number of created pools\n     * @return Number of pools\n     */\n    function getPoolCount() external view returns (uint256) {\n        return allPools.length;\n    }\n    \n    /**\n     * @dev Returns metadata for a specific pool\n     * @param _poolAddress Address of the pool\n     * @return PoolMetadata struct\n     */\n    function getPoolInfo(address _poolAddress) external view returns (PoolMetadata memory) {\n        return poolMetadata[_poolAddress];\n    }\n    \n    /**\n     * @dev Collects fees from a pool (called by PredictionPool)\n     * @param _poolAddress Address of the pool\n     * @param _amount Amount of fees collected\n     * @return Amount collected\n     */\n    function collectFees(address _poolAddress, uint256 _amount) external returns (uint256) {\n        require(poolMetadata[_poolAddress].creator != address(0), \"Pool does not exist\");\n        totalFeesCollected += _amount;\n        emit FeesCollected(_poolAddress, _amount);\n        return _amount;\n    }\n    \n    /**\n     * @dev Withdraws collected fees to owner\n     */\n    function withdrawFees() external onlyOwner nonReentrant {\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"No fees to withdraw\");\n        \n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n        \n        totalFeesCollected = 0; // Reset counter after withdrawal\n        emit FeesWithdrawn(owner(), amount);\n    }\n    \n    /**\n     * @dev Closes a pool (emergency function)\n     * @param _poolAddress Address of the pool to close\n     */\n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolMetadata[_poolAddress].creator != address(0), \"Pool does not exist\");\n        poolMetadata[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n    \n    // ============ RECEIVE FUNCTION ============\n    \n    /**\n     * @dev Allows the contract to receive BNB\n     */\n    receive() external payable {\n        // Accepts BNB transfers (fees from pools)\n    }\n}"
    },
    "PredictionPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./BellaNapoliPredictionFactory.sol\";\nimport \"./TimeConfig.sol\";\n\n/**\n * @title PredictionPool\n * @dev Contract for a single prediction event\n * @author Bella Napoli Team\n */\ncontract PredictionPool is Ownable, ReentrancyGuard {\n    // ============ STATE VARIABLES ============\n    \n    string public title;\n    string public description;\n    string public category;\n    uint256 public closingDate;\n    uint256 public closingBid;\n    address public factory;\n    \n    // Betting data\n    uint256 public totalYes;\n    uint256 public totalNo;\n    uint256 public totalBets;\n    uint256 public totalClaimed;\n    \n    // Winner data\n    bool public winnerSet;\n    bool public winner; // true = YES, false = NO\n    bool public isClosed;\n    \n    // User data\n    mapping(address => Bet) public userBets;\n    mapping(address => bool) public hasClaimed;\n    address[] public bettors;\n    \n    // Fee configuration\n    address public constant FEE_WALLET = 0x17EE2ca31a6811F5d4198bCE9afd1C1db3837A38;\n    uint256 public constant FEE_PERCENTAGE = 150; // 1.5%\n    uint256 public constant BASIS_POINTS = 10000; // 100%\n    \n    // ============ STRUCTS ============\n    \n    struct Bet {\n        uint256 amount;\n        bool choice; // true = YES, false = NO\n        bool claimed;\n        uint256 timestamp;\n    }\n    \n    // ============ EVENTS ============\n    \n    event BetPlaced(address indexed user, uint256 amount, bool choice);\n    event WinnerSet(bool winner);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event FeeTransferred(address indexed feeWallet, uint256 amount);\n    \n    // ============ MODIFIERS ============\n    \n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Only factory can call this function\");\n        _;\n    }\n    \n    // ============ CONSTRUCTOR ============\n    \n    constructor(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid,\n        address _factory\n    ) Ownable() {\n        title = _title;\n        description = _description;\n        category = _category;\n        closingDate = _closingDate;\n        closingBid = _closingBid;\n        factory = _factory;\n    }\n    \n    // ============ EXTERNAL FUNCTIONS ============\n    \n    /**\n     * @dev Places a bet on the prediction\n     * @param _choice true for YES, false for NO\n     */\n    function placeBet(bool _choice) external payable nonReentrant {\n        require(TimeConfig.isBettingOpen(closingDate), \"Betting period has ended\");\n        require(msg.value > 0, \"Bet amount must be greater than 0\");\n        require(userBets[msg.sender].amount == 0, \"Already placed a bet\");\n        \n        userBets[msg.sender] = Bet({\n            amount: msg.value,\n            choice: _choice,\n            claimed: false,\n            timestamp: block.timestamp\n        });\n        \n        if (_choice) {\n            totalYes += msg.value;\n        } else {\n            totalNo += msg.value;\n        }\n        \n        totalBets += msg.value;\n        bettors.push(msg.sender);\n        \n        emit BetPlaced(msg.sender, msg.value, _choice);\n    }\n    \n    /**\n     * @dev Sets the winner (only owner)\n     * @param _winner true for YES, false for NO\n     */\n    function setWinner(bool _winner) external onlyOwner {\n        require(TimeConfig.isPredictionEnded(closingBid), \"Prediction period has not ended\");\n        require(!winnerSet, \"Winner already set\");\n        \n        winner = _winner;\n        winnerSet = true;\n        isClosed = true;\n        \n        emit WinnerSet(_winner);\n    }\n    \n    /**\n     * @dev Claims rewards for winning bets\n     */\n    function claim() external nonReentrant {\n        require(winnerSet, \"Winner not set yet\");\n        require(!isClosed || winnerSet, \"Pool not closed yet\");\n        require(userBets[msg.sender].amount > 0, \"No bet placed\");\n        require(!hasClaimed[msg.sender], \"Already claimed\");\n        require(userBets[msg.sender].choice == winner, \"Not a winning bet\");\n        \n        hasClaimed[msg.sender] = true;\n        userBets[msg.sender].claimed = true;\n        \n        // Calculate pools\n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        \n        // Calculate fee from losing pot (1.5%)\n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        \n        // Send fee to fixed wallet (only on first claim)\n        if (feeAmount > 0 && !hasClaimed[address(0)]) { \n            (bool feeSuccess, ) = payable(FEE_WALLET).call{value: feeAmount}(\"\");\n            require(feeSuccess, \"Fee transfer failed\");\n            hasClaimed[address(0)] = true;\n            emit FeeTransferred(FEE_WALLET, feeAmount);\n        }\n        \n        // Calculate winner's reward\n        uint256 userBetAmount = userBets[msg.sender].amount;\n        require(winningPot > 0, \"Winning pot is zero, no rewards to distribute\");\n        uint256 totalRedistribution = winningPot + netLosingPot;\n        uint256 userReward = (userBetAmount * totalRedistribution) / winningPot;\n        \n        totalClaimed += userReward;\n        \n        // Transfer reward to winner\n        (bool success, ) = payable(msg.sender).call{value: userReward}(\"\");\n        require(success, \"Reward transfer failed\");\n        \n        emit RewardClaimed(msg.sender, userReward);\n    }\n    \n    // ============ VIEW FUNCTIONS ============\n    \n    /**\n     * @dev Returns basic pool information\n     */\n    function getPoolInfo() external view returns (string memory, string memory, string memory, uint256, uint256) {\n        return (title, description, category, closingDate, closingBid);\n    }\n    \n    /**\n     * @dev Returns pool statistics\n     */\n    function getPoolStats() external view returns (uint256, uint256, uint256, uint256, bool, bool, bool) {\n        return (totalYes, totalNo, totalBets, totalClaimed, winnerSet, isClosed, winner);\n    }\n    \n    /**\n     * @dev Returns fee information\n     */\n    function getFeeInfo() external pure returns (address, uint256, uint256, bool) {\n        return (FEE_WALLET, FEE_PERCENTAGE, BASIS_POINTS, true);\n    }\n    \n    /**\n     * @dev Returns redistribution information\n     */\n    function getRedistributionInfo() external view returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 winningPot = winner ? totalYes : totalNo;\n        uint256 losingPot = winner ? totalNo : totalYes;\n        uint256 feeAmount = (losingPot * FEE_PERCENTAGE) / BASIS_POINTS;\n        uint256 netLosingPot = losingPot - feeAmount;\n        uint256 totalRedistribution = winningPot + netLosingPot;\n        \n        return (winningPot, losingPot, feeAmount, netLosingPot, totalRedistribution);\n    }\n    \n    /**\n     * @dev Returns all bettors\n     */\n    function getBettors() external view returns (address[] memory) {\n        return bettors;\n    }\n    \n    /**\n     * @dev Returns user's bet information\n     */\n    function getBet(address _user) external view returns (Bet memory) {\n        return userBets[_user];\n    }\n    \n    /**\n     * @dev Returns winning pot amount\n     */\n    function getWinningPot() external view returns (uint256) {\n        return winner ? totalYes : totalNo;\n    }\n    \n    /**\n     * @dev Returns losing pot amount\n     */\n    function getLosingPot() external view returns (uint256) {\n        return winner ? totalNo : totalYes;\n    }\n    \n    // ============ RECEIVE FUNCTION ============\n    \n    /**\n     * @dev Allows the contract to receive BNB\n     */\n    receive() external payable {\n        // Accepts BNB transfers\n    }\n}"
    },
    "TimeConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title TimeConfig\n * @dev Configuration file for Italian timezone timestamps\n * @author Bella Napoli Team\n */\nlibrary TimeConfig {\n    // Real dates for production (Italian times converted to UTC)\n    // Closing bets: 15 November 2025, 21:59 CET = 15 November 2025, 20:59 UTC\n    // Prediction expiry: 31 December 2025, 21:59 CET = 31 December 2025, 20:59 UTC\n    uint256 public constant REAL_CLOSING_DATE = 1763236740; // 15 November 2025, 20:59 UTC\n    uint256 public constant REAL_CLOSING_BID = 1767211140;  // 31 December 2025, 20:59 UTC\n    \n    /**\n     * @dev Checks if betting is still open\n     * @param _closingDate Unix timestamp when betting closes\n     * @return true if betting is open\n     */\n    function isBettingOpen(uint256 _closingDate) internal view returns (bool) {\n        return block.timestamp <= _closingDate;\n    }\n    \n    /**\n     * @dev Checks if prediction event has ended\n     * @param _closingBid Unix timestamp when prediction expires\n     * @return true if prediction has ended\n     */\n    function isPredictionEnded(uint256 _closingBid) internal view returns (bool) {\n        return block.timestamp > _closingBid;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["*"]
      }
    }
  }
}
