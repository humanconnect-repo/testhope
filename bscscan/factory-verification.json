{
  "language": "Solidity",
  "sources": {
    "BellaNapoliPredictionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Minimal Ownable implementation\nabstract contract Ownable {\n    address private _owner;\n    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n    \n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    \n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    \n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// Minimal ReentrancyGuard implementation\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    \n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n    \n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract BellaNapoliPredictionFactory is Ownable, ReentrancyGuard {\n    address[] public allPools;\n    mapping(address => PoolMetadata) public poolMetadata;\n    uint256 public totalFeesCollected;\n    \n    struct PoolMetadata {\n        string title;\n        string description;\n        string category;\n        uint256 closingDate;\n        uint256 closingBid;\n        address creator;\n        bool isActive;\n        uint256 createdAt;\n    }\n    \n    event PoolCreated(\n        address indexed poolAddress,\n        address indexed creator,\n        string title,\n        string category,\n        uint256 closingDate,\n        uint256 closingBid\n    );\n    \n    event PoolClosed(address indexed poolAddress, bool isActive);\n    event FeesCollected(address indexed poolAddress, uint256 amount);\n    event FeesWithdrawn(address indexed owner, uint256 amount);\n    \n    constructor() Ownable() {}\n    \n    function createPool(\n        string memory _title,\n        string memory _description,\n        string memory _category,\n        uint256 _closingDate,\n        uint256 _closingBid\n    ) external onlyOwner nonReentrant returns (address) {\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\n        require(bytes(_category).length > 0, \"Category cannot be empty\");\n        require(_closingDate > block.timestamp, \"Closing date must be in the future\");\n        require(_closingBid > _closingDate, \"Closing bid must be after closing date\");\n        \n        // For now, return a placeholder address\n        // In production, this would deploy a new PredictionPool\n        address poolAddress = address(uint160(uint256(keccak256(abi.encodePacked(_title, block.timestamp)))));\n        \n        allPools.push(poolAddress);\n        \n        poolMetadata[poolAddress] = PoolMetadata({\n            title: _title,\n            description: _description,\n            category: _category,\n            closingDate: _closingDate,\n            closingBid: _closingBid,\n            creator: _msgSender(),\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        emit PoolCreated(poolAddress, _msgSender(), _title, _category, _closingDate, _closingBid);\n        \n        return poolAddress;\n    }\n    \n    function getAllPools() external view returns (address[] memory) {\n        return allPools;\n    }\n    \n    function getPoolCount() external view returns (uint256) {\n        return allPools.length;\n    }\n    \n    function getPoolInfo(address _poolAddress) external view returns (PoolMetadata memory) {\n        return poolMetadata[_poolAddress];\n    }\n    \n    function collectFees(address _poolAddress, uint256 _amount) external returns (uint256) {\n        require(poolMetadata[_poolAddress].creator != address(0), \"Pool does not exist\");\n        totalFeesCollected += _amount;\n        emit FeesCollected(_poolAddress, _amount);\n        return _amount;\n    }\n    \n    function withdrawFees() external onlyOwner nonReentrant {\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"No fees to withdraw\");\n        \n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Fee withdrawal failed\");\n        \n        totalFeesCollected = 0;\n        emit FeesWithdrawn(owner(), amount);\n    }\n    \n    function closePool(address _poolAddress) external onlyOwner {\n        require(poolMetadata[_poolAddress].creator != address(0), \"Pool does not exist\");\n        poolMetadata[_poolAddress].isActive = false;\n        emit PoolClosed(_poolAddress, false);\n    }\n    \n    receive() external payable {}\n    \n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["*"]
      }
    }
  }
}
